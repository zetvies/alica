<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ALiCA - Command Interface</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Courier New', monospace;
            background: #1a1a1a;
            color: #e0e0e0;
            height: 100vh;
            overflow: hidden;
        }
        
        #commandArea {
            width: 100%;
            height: 100vh;
            padding: 20px;
            background: #0f0f0f;
            border: none;
            color: #e0e0e0;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            line-height: 1.6;
            resize: none;
            outline: none;
            tab-size: 2;
            white-space: pre;
            overflow-wrap: normal;
            overflow-x: auto;
        }
        
        #commandArea::placeholder {
            color: #666;
        }
        
        #status {
            position: fixed;
            top: 10px;
            right: 10px;
            padding: 8px 16px;
            border-radius: 4px;
            font-size: 12px;
            font-weight: bold;
            z-index: 1000;
            background: #333;
            border: 1px solid #555;
        }
        
        #status.connected {
            background: #2d5016;
            border-color: #4a7c2a;
            color: #a5d97a;
        }
        
        #status.disconnected {
            background: #501616;
            border-color: #7c2a2a;
            color: #d97a7a;
        }
        
        #hint {
            position: fixed;
            bottom: 10px;
            left: 10px;
            padding: 8px 12px;
            background: rgba(0, 0, 0, 0.7);
            border-radius: 4px;
            font-size: 11px;
            color: #888;
            z-index: 1000;
        }
        
        #abletonInfo {
            position: fixed;
            top: 10px;
            left: 10px;
            padding: 8px 16px;
            border-radius: 4px;
            font-size: 13px;
            font-weight: bold;
            z-index: 1000;
            background: #1a1a1a;
            border: 1px solid #444;
            color: #e0e0e0;
            display: flex;
            align-items: center;
            gap: 20px;
        }
        
        #bpmDisplay {
            color: #4a9eff;
        }
        
        #signatureDisplay {
            color: #9c27b0;
        }
        
        #beatSequencer {
            display: flex;
            gap: 6px;
            align-items: center;
        }
        
        .beatCircle {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: #444;
            border: 1px solid #666;
            transition: all 0.1s ease;
        }
        
        .beatCircle.active {
            background: #4a9eff;
            box-shadow: 0 0 8px #4a9eff;
            border-color: #6bb5ff;
            transform: scale(1.2);
        }
    </style>
</head>
<body>
    <div id="status" class="disconnected">Disconnected</div>
    <div id="abletonInfo">
        <span id="bpmDisplay">BPM: --</span>
        <span id="signatureDisplay">Signature: --/--</span>
        <div id="beatSequencer"></div>
        </div>
        <div id="hint">
        <strong>Shortcuts:</strong> Ctrl+/ (toggle comment), Ctrl+S (save/queue cycle), Ctrl+Enter (queue track), Ctrl+Alt+S (play cycle), Ctrl+Alt+Enter (play track)<br>
        For Enter: no Shift = current track, + Shift = selected lines
        </div>
    <textarea id="commandArea" placeholder="Enter ALiCA commands here...&#10;&#10;Examples:&#10;t(mainLoop).bpm(80).sn(4).sd(8).play([n(<c3,e3,g3>)].c(1) [a(7).from(127).to(0)].c(1))&#10;&#10;playCycle('t(example).bpm(120).sn(4).sd(4).play([n(c3) n(c3)].c(1))')&#10;playTrack('t(test).bpm(100).sn(4).sd(4).play([a(7).from(0).to(127)].c(1))')"></textarea>

    <script>
        let ws = null;
        let reconnectTimeout = null;
        let reconnectAttempts = 0;
        const maxReconnectAttempts = Infinity; // Keep trying forever
        const reconnectDelay = 3000; // Start with 3 seconds
        const maxReconnectDelay = 30000; // Max 30 seconds
        const statusEl = document.getElementById('status');
        const commandArea = document.getElementById('commandArea');
        
        function connect() {
            // Clear any existing reconnect timeout
            if (reconnectTimeout) {
                clearTimeout(reconnectTimeout);
                reconnectTimeout = null;
            }
            
            // Close existing connection if any
            if (ws) {
                ws.onclose = null; // Prevent infinite loop
                ws.close();
            }
            
            try {
                ws = new WebSocket(`ws://localhost:4254`);
        
        ws.onopen = () => {
            statusEl.textContent = 'Connected';
            statusEl.className = 'status connected';
                    reconnectAttempts = 0; // Reset on successful connection
            console.log('WebSocket connected');
        };
        
                ws.onclose = (event) => {
            statusEl.textContent = 'Disconnected';
            statusEl.className = 'status disconnected';
                    console.log('WebSocket disconnected', event.code, event.reason);
                    
                    // Attempt to reconnect (unless it was a clean close or manual close)
                    if (event.code !== 1000) { // 1000 = normal closure
                        scheduleReconnect();
                    }
        };
        
        ws.onerror = (error) => {
            console.error('WebSocket error:', error);
                    statusEl.textContent = 'Error';
                    statusEl.className = 'status disconnected';
        };
        
        ws.onmessage = (event) => {
            const data = JSON.parse(event.data);
            console.log('Received:', data);
                    
                    // Handle BPM and signature updates
                    if (data.type === 'tempoAndSignature') {
                        updateAbletonInfo(data.tempo, data.signatureNumerator, data.signatureDenominator);
                        // Update sequencer when signature changes
                        if (data.signatureNumerator) {
                            updateBeatSequencer(data.signatureNumerator);
                        }
                    }
                    
                    // Handle beat updates
                    if (data.type === 'beat' && data.beatNumber !== undefined) {
                        updateBeatIndicator(data.beatNumber, data.bar);
                    }
                };
                
            } catch (error) {
                console.error('Failed to create WebSocket:', error);
                scheduleReconnect();
            }
        }
        
        function scheduleReconnect() {
            // Don't schedule if already scheduled
            if (reconnectTimeout) return;
            
            reconnectAttempts++;
            
            // Calculate delay with exponential backoff (capped at maxReconnectDelay)
            const delay = Math.min(reconnectDelay * Math.pow(1.5, reconnectAttempts - 1), maxReconnectDelay);
            
            statusEl.textContent = `Reconnecting... (attempt ${reconnectAttempts})`;
            console.log(`Scheduling reconnect in ${delay}ms (attempt ${reconnectAttempts})`);
            
            reconnectTimeout = setTimeout(() => {
                reconnectTimeout = null;
                connect();
            }, delay);
        }
        
        // Initial connection
        connect();
        
        // Handle keyboard shortcuts
        commandArea.addEventListener('keydown', (e) => {
            const isCtrl = e.ctrlKey || e.metaKey;
            const isShift = e.shiftKey;
            const isAlt = e.altKey;
            
            // Ctrl + / = toggle comment on selected lines
            if (isCtrl && !isAlt && !isShift && (e.key === '/' || e.key === '?')) {
                e.preventDefault();
                toggleComment();
            }
            // Ctrl + S = save whole track (queue playCycle for current track)
            else if (isCtrl && !isAlt && !isShift && e.key === 's') {
                e.preventDefault();
                queuePlayCycleForCurrentTrack();
            }
            // Ctrl + Enter = queue playTrack for current track (SWAPPED)
            else if (isCtrl && !isAlt && !isShift && e.key === 'Enter') {
                e.preventDefault();
                queuePlayTrackForCurrentTrack();
            }
            // Ctrl + Shift + Enter = queue playTrack for selected lines (SWAPPED)
            else if (isCtrl && !isAlt && isShift && e.key === 'Enter') {
                e.preventDefault();
                queuePlayTrackForSelection();
            }
            // Ctrl + Alt + S = playCycle for selected lines
            else if (isCtrl && isAlt && !isShift && e.key === 's') {
                e.preventDefault();
                playCycleForSelection();
            }
            // Ctrl + Alt + Shift + S = playCycle for current track
            else if (isCtrl && isAlt && isShift && e.key === 'S') {
                e.preventDefault();
                playCycleForCurrentTrack();
            }
            // Ctrl + Alt + Enter = playTrack for current track (SWAPPED)
            else if (isCtrl && isAlt && !isShift && e.key === 'Enter') {
                e.preventDefault();
                playTrackForCurrentTrack();
            }
            // Ctrl + Alt + Shift + Enter = playTrack for selected lines (SWAPPED)
            else if (isCtrl && isAlt && isShift && e.key === 'Enter') {
                e.preventDefault();
                playTrackForSelection();
            }
        });
        
        // Get selected text from textarea
        function getSelectedText() {
            const start = commandArea.selectionStart;
            const end = commandArea.selectionEnd;
            if (start === end) return null; // No selection
            return commandArea.value.substring(start, end);
        }
        
        // Toggle comment on selected lines
        function toggleComment() {
            const fullText = commandArea.value;
            const start = commandArea.selectionStart;
            const end = commandArea.selectionEnd;
            
            // Find the lines that contain the selection
            let lineStart = start;
            let lineEnd = end;
            
            // Find start of first line containing selection
            while (lineStart > 0 && fullText[lineStart - 1] !== '\n') {
                lineStart--;
            }
            
            // Find end of last line containing selection
            while (lineEnd < fullText.length && fullText[lineEnd] !== '\n') {
                lineEnd++;
            }
            
            // Get all lines in the selection
            const selectedText = fullText.substring(lineStart, lineEnd);
            const lines = selectedText.split('\n');
            
            // Determine if all selected lines are commented (to decide toggle direction)
            let allCommented = true;
            let someCommented = false;
            for (const line of lines) {
                const trimmed = line.trim();
                if (trimmed && !trimmed.startsWith('//')) {
                    allCommented = false;
                } else if (trimmed && trimmed.startsWith('//')) {
                    someCommented = true;
                }
            }
            
            // Process each line
            const processedLines = lines.map(line => {
                const trimmed = line.trim();
                
                // Empty line - return as-is
                if (!trimmed) return line;
                
                // If line starts with //, remove comment
                if (trimmed.startsWith('//')) {
                    // Remove // and any space after it, but preserve indentation
                    const commentIndex = line.indexOf('//');
                    const afterComment = line.substring(commentIndex + 2).trimStart();
                    const beforeComment = line.substring(0, commentIndex);
                    return beforeComment + afterComment;
                } else {
                    // Add // at the start (preserve indentation)
                    const leadingWhitespace = line.match(/^\s*/)[0];
                    const restOfLine = line.substring(leadingWhitespace.length);
                    return leadingWhitespace + '//' + restOfLine;
                }
            });
            
            // Replace the selected lines
            const newText = fullText.substring(0, lineStart) + 
                          processedLines.join('\n') + 
                          fullText.substring(lineEnd);
            
            // Update textarea
            commandArea.value = newText;
            
            // Restore selection (adjust for length changes)
            const lengthDiff = newText.length - fullText.length;
            commandArea.selectionStart = lineStart;
            commandArea.selectionEnd = lineEnd + lengthDiff;
        }
        
        // Get selected lines or line containing cursor
        function getSelectedLines() {
            const fullText = commandArea.value;
            const start = commandArea.selectionStart;
            const end = commandArea.selectionEnd;
            
            // Check if there's actual text selection (not just cursor position)
            const hasSelection = start !== end;
            
            if (hasSelection) {
                // Use actual selection boundaries
                let lineStart = start;
                let lineEnd = end;
                
                // Find start of first line containing selection
                while (lineStart > 0 && fullText[lineStart - 1] !== '\n') {
                    lineStart--;
                }
                
                // Find end of last line containing selection
                while (lineEnd < fullText.length && fullText[lineEnd] !== '\n') {
                    lineEnd++;
                }
                
                const selectedText = fullText.substring(lineStart, lineEnd);
                // Get all lines within selection, filtering empty and comments
                const lines = selectedText.split('\n').filter(line => {
                    const trimmed = line.trim();
                    return trimmed && !trimmed.startsWith('//');
                });
                
                if (lines.length === 0) return null;
                // Join all selected lines
                return lines.join(' ');
            } else {
                // No selection - use line containing cursor
                const cursorPos = start;
                let lineStart = cursorPos;
                let lineEnd = cursorPos;
                
                // Find start of line containing cursor
                while (lineStart > 0 && fullText[lineStart - 1] !== '\n') {
                    lineStart--;
                }
                
                // Find end of line containing cursor
                while (lineEnd < fullText.length && fullText[lineEnd] !== '\n') {
                    lineEnd++;
                }
                
                const lineText = fullText.substring(lineStart, lineEnd).trim();
                if (!lineText || lineText.startsWith('//')) return null;
                
                return lineText;
            }
        }
        
        // Remove comments (lines starting with //) from text
        function removeComments(text) {
            if (!text) return text;
            const lines = text.split('\n');
            const filteredLines = lines.map(line => {
                // Find // on the line and remove everything from // to end of line
                const commentIndex = line.indexOf('//');
                if (commentIndex !== -1) {
                    // Check if // is not inside quotes or within another token
                    // Simple check: if // appears, remove from that position to end of line
                    return line.substring(0, commentIndex);
                }
                return line;
            });
            return filteredLines.join('\n');
        }
        
        // Check if text matches t(...).stop() or t(...).play(...).stop() syntax
        function isStopSyntax(text) {
            if (!text) return false;
            const trimmed = text.trim().replace(/\s+/g, '');
            // Match: t(...).stop() or t(...).stop or t(...).play(...).stop() or t(...).play(...).stop
            const stopMatch = trimmed.match(/^t\([^)]+\)(?:\.(?:bpm|sn|sd)\([^)]+\))*(?:\.play\([^)]*\))?\.stop\(?\)?$/);
            return stopMatch !== null;
        }
        
        // Find the t(...).play(...) or t(...).play(...).stop() wrapper that contains the cursor/selection
        function findCurrentTrack() {
            const fullText = commandArea.value;
            const cursorPos = commandArea.selectionStart;
            
            // Find the nearest t(...) before cursor
            let searchStart = 0;
            let bestMatch = null;
            let bestEnd = -1;
            
            while (true) {
                const tIndex = fullText.indexOf('t(', searchStart);
                if (tIndex === -1 || tIndex > cursorPos) break;
                
                // Find matching closing parenthesis for .play(...) and optionally .stop()
                let depth = 0;
                let pos = tIndex;
                let inPlay = false;
                let playStartPos = -1;
                let playEndPos = -1;
                
                while (pos < fullText.length) {
                    if (fullText.substring(pos).startsWith('.play(')) {
                        inPlay = true;
                        playStartPos = pos + 6; // Position after '.play('
                        pos += 6; // Skip '.play('
                        depth = 1;
                        continue;
                    }
                    
                    if (fullText[pos] === '(') depth++;
                    else if (fullText[pos] === ')') {
                        depth--;
                        if (inPlay && depth === 0) {
                            // Found complete t(...).play(...)
                            playEndPos = pos + 1;
                            
                            // Check for .stop() after .play(...)
                            let afterPlayPos = playEndPos;
                            // Skip whitespace
                            while (afterPlayPos < fullText.length && /\s/.test(fullText[afterPlayPos])) {
                                afterPlayPos++;
                            }
                            
                            // Check if .stop() or .stop follows
                            if (fullText.substring(afterPlayPos).startsWith('.stop()')) {
                                const stopEnd = afterPlayPos + 7;
                                // Check if cursor is within this track including stop
                                if (cursorPos >= tIndex && cursorPos <= stopEnd) {
                                    bestMatch = fullText.substring(tIndex, stopEnd);
                                    bestEnd = stopEnd;
                                    break;
                                }
                            } else if (fullText.substring(afterPlayPos).startsWith('.stop')) {
                                const stopEnd = afterPlayPos + 6;
                                // Check if cursor is within this track including stop
                                if (cursorPos >= tIndex && cursorPos <= stopEnd) {
                                    bestMatch = fullText.substring(tIndex, stopEnd);
                                    bestEnd = stopEnd;
                                    break;
                                }
                            }
                            
                            // Check if cursor is within this track (without stop)
                            if (cursorPos >= tIndex && cursorPos <= playEndPos) {
                                bestMatch = fullText.substring(tIndex, playEndPos);
                                bestEnd = playEndPos;
                                break;
                            }
                            break;
                        }
                    }
                    pos++;
                }
                
                searchStart = tIndex + 2;
            }
            
            // Also check for standalone t(...).stop() (without .play())
            if (!bestMatch || cursorPos > bestEnd) {
                searchStart = 0;
                while (true) {
                    const tIndex = fullText.indexOf('t(', searchStart);
                    if (tIndex === -1 || tIndex > cursorPos) break;
                    
                    // Find the end of t(...)
                    let pos = tIndex + 2;
                    let depth = 1;
                    while (pos < fullText.length && depth > 0) {
                        if (fullText[pos] === '(') depth++;
                        else if (fullText[pos] === ')') depth--;
                        pos++;
                    }
                    
                    if (depth === 0) {
                        // Check for .stop() after t(...)
                        let afterT = pos;
                        // Skip whitespace
                        while (afterT < fullText.length && /\s/.test(fullText[afterT])) {
                            afterT++;
                        }
                        
                        // Check if .stop() or .stop follows
                        if (fullText.substring(afterT).startsWith('.stop()')) {
                            const stopEnd = afterT + 7;
                            if (cursorPos >= tIndex && cursorPos <= stopEnd) {
                                bestMatch = fullText.substring(tIndex, stopEnd);
                                bestEnd = stopEnd;
                                break;
                            }
                        } else if (fullText.substring(afterT).startsWith('.stop')) {
                            const stopEnd = afterT + 6;
                            if (cursorPos >= tIndex && cursorPos <= stopEnd) {
                                bestMatch = fullText.substring(tIndex, stopEnd);
                                bestEnd = stopEnd;
                                break;
                            }
                        }
                    }
                    
                    searchStart = tIndex + 2;
                }
            }
            
            // Remove comments from the found track
            if (bestMatch) {
                bestMatch = removeComments(bestMatch);
            }
            
            return bestMatch;
        }
        
        // Apply t() wrapper settings to a sequence string
        function applyWrapperSettings(sequenceStr, wrapperStr) {
            if (!wrapperStr || !wrapperStr.startsWith('t(')) {
                return sequenceStr; // No wrapper, return as-is
            }
            
            const parsed = parseMethodChain(wrapperStr);
            if (!parsed) return sequenceStr;
            
            // Extract cycleId and build new t() wrapper with sequence
            const match = wrapperStr.match(/^t\(([^)]+)\)/);
            if (!match) return sequenceStr;
            
            const cycleId = match[1];
            let result = `t(${cycleId})`;
            
            if (parsed.tempo !== null) result += `.bpm(${parsed.tempo})`;
            if (parsed.sn !== null) result += `.sn(${parsed.sn})`;
            if (parsed.sd !== null) result += `.sd(${parsed.sd})`;
            
            result += `.play(${sequenceStr})`;
            return result;
        }
        
        // Queue playCycle for selected lines
        function queuePlayCycleForSelection() {
            const selectedSeq = getSelectedLines();
            if (!selectedSeq) {
                console.warn('No valid sequence selected');
                return;
            }
            
            // Check if selected text is a stop command
            if (isStopSyntax(selectedSeq)) {
                sendToServer({
                    action: 'playTrack', // Use any action, server will detect stop syntax
                    cycleStr: selectedSeq
                });
                return;
            }
            
            const wrapper = findCurrentTrack();
            const fullCommand = applyWrapperSettings(selectedSeq, wrapper);
            const cleanCommand = removeComments(fullCommand);
            
            // Check again after applying wrapper settings
            if (isStopSyntax(cleanCommand)) {
                sendToServer({
                    action: 'playTrack', // Use any action, server will detect stop syntax
                    cycleStr: cleanCommand
                });
                return;
            }
            
            const parsed = parseMethodChain(cleanCommand);
            
            sendToServer({
                action: 'addCycleToQueue',
                id: null,
                cycleStr: cleanCommand,
                tempo: parsed?.tempo || null,
                signatureNumerator: parsed?.sn || null,
                signatureDenominator: parsed?.sd || null
            });
        }
        
        // Queue playCycle for current track
        function queuePlayCycleForCurrentTrack() {
            const track = findCurrentTrack();
            if (!track) {
                console.warn('No t() track found');
                return;
            }
            
            // Check if it's a stop command
            if (isStopSyntax(track)) {
                sendToServer({
                    action: 'playTrack', // Use any action, server will detect stop syntax
                    cycleStr: track
                });
                return;
            }
            
            const cleanTrack = removeComments(track);
            const parsed = parseMethodChain(cleanTrack);
            sendToServer({
                action: 'addCycleToQueue',
                id: null,
                cycleStr: cleanTrack,
                tempo: parsed?.tempo || null,
                signatureNumerator: parsed?.sn || null,
                signatureDenominator: parsed?.sd || null
            });
        }
        
        // Queue playTrack for selected lines
        function queuePlayTrackForSelection() {
            const selectedSeq = getSelectedLines();
            if (!selectedSeq) {
                console.warn('No valid sequence selected');
                return;
            }
            
            // Check if selected text is a stop command
            if (isStopSyntax(selectedSeq)) {
                sendToServer({
                    action: 'playTrack', // Use any action, server will detect stop syntax
                    cycleStr: selectedSeq
                });
                return;
            }
            
            const wrapper = findCurrentTrack();
            const fullCommand = applyWrapperSettings(selectedSeq, wrapper);
            const cleanCommand = removeComments(fullCommand);
            
            // Check again after applying wrapper settings
            if (isStopSyntax(cleanCommand)) {
                sendToServer({
                    action: 'playTrack', // Use any action, server will detect stop syntax
                    cycleStr: cleanCommand
                });
                return;
            }
            
            const parsed = parseMethodChain(cleanCommand);
            
            sendToServer({
                action: 'addTrackToQueue',
                id: null,
                cycleStr: cleanCommand,
                tempo: parsed?.tempo || null,
                signatureNumerator: parsed?.sn || null,
                signatureDenominator: parsed?.sd || null
            });
        }
        
        // Queue playTrack for current track
        function queuePlayTrackForCurrentTrack() {
            const track = findCurrentTrack();
            if (!track) {
                console.warn('No t() track found');
                return;
            }
            
            // Check if it's a stop command
            if (isStopSyntax(track)) {
                sendToServer({
                    action: 'playTrack', // Use any action, server will detect stop syntax
                    cycleStr: track
                });
                return;
            }
            
            const cleanTrack = removeComments(track);
            const parsed = parseMethodChain(cleanTrack);
            sendToServer({
                action: 'addTrackToQueue',
                id: null,
                cycleStr: cleanTrack,
                tempo: parsed?.tempo || null,
                signatureNumerator: parsed?.sn || null,
                signatureDenominator: parsed?.sd || null
            });
        }
        
        // Play playCycle for selected lines (immediate)
        function playCycleForSelection() {
            const selectedSeq = getSelectedLines();
            if (!selectedSeq) {
                console.warn('No valid sequence selected');
                return;
            }
            
            // Check if selected text is a stop command
            if (isStopSyntax(selectedSeq)) {
                sendToServer({
                    action: 'playTrack', // Use any action, server will detect stop syntax
                    cycleStr: selectedSeq
                });
                return;
            }
            
            const wrapper = findCurrentTrack();
            const fullCommand = applyWrapperSettings(selectedSeq, wrapper);
            const cleanCommand = removeComments(fullCommand);
            
            // Check again after applying wrapper settings
            if (isStopSyntax(cleanCommand)) {
                sendToServer({
                    action: 'playTrack', // Use any action, server will detect stop syntax
                    cycleStr: cleanCommand
                });
                return;
            }
            
            const parsed = parseMethodChain(cleanCommand);
            
            sendToServer({
                action: 'playCycle',
                id: null,
                cycleStr: cleanCommand,
                tempo: parsed?.tempo || null,
                signatureNumerator: parsed?.sn || null,
                signatureDenominator: parsed?.sd || null
            });
        }
        
        // Play playCycle for current track (immediate)
        function playCycleForCurrentTrack() {
            const track = findCurrentTrack();
            if (!track) {
                console.warn('No t() track found');
                return;
            }
            
            // Check if it's a stop command
            if (isStopSyntax(track)) {
                sendToServer({
                    action: 'playTrack', // Use any action, server will detect stop syntax
                    cycleStr: track
                });
                return;
            }
            
            const cleanTrack = removeComments(track);
            const parsed = parseMethodChain(cleanTrack);
            sendToServer({
                action: 'playCycle',
                id: null,
                cycleStr: cleanTrack,
                tempo: parsed?.tempo || null,
                signatureNumerator: parsed?.sn || null,
                signatureDenominator: parsed?.sd || null
            });
        }
        
        // Play playTrack for selected lines (immediate)
        function playTrackForSelection() {
            const selectedSeq = getSelectedLines();
            if (!selectedSeq) {
                console.warn('No valid sequence selected');
                return;
            }
            
            // Check if selected text is a stop command
            if (isStopSyntax(selectedSeq)) {
                sendToServer({
                    action: 'playTrack', // Use any action, server will detect stop syntax
                    cycleStr: selectedSeq
                });
                return;
            }
            
            const wrapper = findCurrentTrack();
            const fullCommand = applyWrapperSettings(selectedSeq, wrapper);
            const cleanCommand = removeComments(fullCommand);
            
            // Check again after applying wrapper settings
            if (isStopSyntax(cleanCommand)) {
                sendToServer({
                    action: 'playTrack', // Use any action, server will detect stop syntax
                    cycleStr: cleanCommand
                });
                return;
            }
            
            const parsed = parseMethodChain(cleanCommand);
            
            sendToServer({
                action: 'playTrack',
                id: null,
                cycleStr: cleanCommand,
                tempo: parsed?.tempo || null,
                signatureNumerator: parsed?.sn || null,
                signatureDenominator: parsed?.sd || null
            });
        }
        
        // Play playTrack for current track (immediate)
        function playTrackForCurrentTrack() {
            const track = findCurrentTrack();
            if (!track) {
                console.warn('No t() track found');
                return;
            }
            
            // Check if it's a stop command
            if (isStopSyntax(track)) {
                sendToServer({
                    action: 'playTrack', // Use any action, server will detect stop syntax
                    cycleStr: track
                });
                return;
            }
            
            const cleanTrack = removeComments(track);
            const parsed = parseMethodChain(cleanTrack);
            sendToServer({
                action: 'playTrack',
                id: null,
                cycleStr: cleanTrack,
                tempo: parsed?.tempo || null,
                signatureNumerator: parsed?.sn || null,
                signatureDenominator: parsed?.sd || null
            });
        }
        
        // Join multi-line commands by tracking parentheses depth
        function joinMultiLineCommand(text) {
            const lines = text.split('\n');
            const commands = [];
            let currentCommand = '';
            let parenDepth = 0;
            let inString = false;
            let stringChar = null;
            
            for (const line of lines) {
                const trimmed = line.trim();
                
                // Skip empty lines and comments (but only when not in the middle of a command)
                if (!trimmed || trimmed.startsWith('//')) {
                    if (currentCommand && parenDepth === 0) {
                        commands.push(currentCommand.trim());
                        currentCommand = '';
                    }
                    continue;
                }
                
                // Track parentheses and strings across the entire line
                for (let i = 0; i < line.length; i++) {
                    const char = line[i];
                    const prevChar = i > 0 ? line[i-1] : null;
                    
                    if (!inString && (char === '"' || char === "'")) {
                        inString = true;
                        stringChar = char;
                    } else if (inString && char === stringChar && prevChar !== '\\') {
                        inString = false;
                        stringChar = null;
                    } else if (!inString) {
                        if (char === '(') parenDepth++;
                        else if (char === ')') parenDepth--;
                    }
                }
                
                // Add line to current command
                if (currentCommand) {
                    currentCommand += ' ' + trimmed;
                } else {
                    currentCommand = trimmed;
                }
                
                // If we've closed all parentheses and not in a string, command is complete
                if (parenDepth === 0 && !inString && currentCommand) {
                    commands.push(currentCommand.trim());
                    currentCommand = '';
                    parenDepth = 0;
                }
            }
            
            // Add any remaining command
            if (currentCommand.trim()) {
                commands.push(currentCommand.trim());
            }
            
            return commands.filter(cmd => cmd.length > 0);
        }
        
        // Split text into individual commands (now simplified since joinMultiLineCommand handles it)
        function splitCommands(text) {
            // The joinMultiLineCommand already returns an array of commands
            // But if text wasn't processed, split by newlines and filter
            const commands = Array.isArray(text) ? text : [text];
            return commands.filter(cmd => cmd.trim() && !cmd.trim().startsWith('//'));
        }
        
        // Helper function to evaluate chained multiplication/division expressions
        // Supports: baseValue*2/3*4, where baseValue can be tmp, sn, sd, or a number
        function evaluateExpression(expr, context = {}) {
            if (!expr || typeof expr !== 'string') return null;
            
            const norm = expr.trim().toLowerCase();
            
            // Parse base value: tmp, sn, sd, or a number
            let baseValue = null;
            let remainingExpr = '';
            
            if (norm === 'tmp' && context.tmp !== undefined && context.tmp !== null) {
                baseValue = context.tmp;
            } else if (norm === 'sn' && context.sn !== undefined && context.sn !== null) {
                baseValue = context.sn;
            } else if (norm === 'sd' && context.sd !== undefined && context.sd !== null) {
                baseValue = context.sd;
            } else if (norm.startsWith('tmp')) {
                if (context.tmp !== undefined && context.tmp !== null) {
                    baseValue = context.tmp;
                    remainingExpr = norm.substring(3); // Remove 'tmp' prefix
                }
            } else if (norm.startsWith('sn')) {
                if (context.sn !== undefined && context.sn !== null) {
                    baseValue = context.sn;
                    remainingExpr = norm.substring(2); // Remove 'sn' prefix
                }
            } else if (norm.startsWith('sd')) {
                if (context.sd !== undefined && context.sd !== null) {
                    baseValue = context.sd;
                    remainingExpr = norm.substring(2); // Remove 'sd' prefix
                }
            } else {
                // Try to parse as a number
                const numMatch = norm.match(/^(\d+(?:\.\d+)?)/);
                if (numMatch) {
                    baseValue = parseFloat(numMatch[1]);
                    remainingExpr = norm.substring(numMatch[1].length);
                }
            }
            
            if (baseValue === null || isNaN(baseValue)) return null;
            
            // If no remaining expression, return base value
            if (!remainingExpr) return baseValue;
            
            // Parse and apply operations from left to right
            // Pattern: *N or /N, where N can be any number
            const operationRegex = /([*\/])(\d+(?:\.\d+)?)/g;
            let result = baseValue;
            let match;
            let lastIndex = 0;
            
            while ((match = operationRegex.exec(remainingExpr)) !== null) {
                // Check that we're starting where we left off (no gaps)
                if (match.index !== lastIndex) {
                    return null; // Invalid - there's text between operations
                }
                
                const op = match[1];
                const num = parseFloat(match[2]);
                
                if (isNaN(num) || num <= 0) return null; // Invalid operation
                
                if (op === '*') {
                    result = result * num;
                } else if (op === '/') {
                    result = result / num;
                }
                
                lastIndex = match.index + match[0].length;
            }
            
            // Check if we consumed the entire expression
            if (lastIndex !== remainingExpr.length) {
                // There's extra text that wasn't consumed - invalid expression
                return null;
            }
            
            return result;
        }
        
        // Simple parser for new syntax (client-side helper)
        function parseMethodChain(str) {
            if (!str || !str.trim().startsWith('t(')) return null;
            
            const match = str.match(/^t\(([^)]+)\)/);
            if (!match) return null;
            
            const cycleId = match[1].trim();
            let bpm = null, sn = null, sd = null;
            
            // Parse .bpm(...)
            const bpmMatch = str.match(/\.bpm\(([^)]+)\)/);
            if (bpmMatch) {
                const bpmStr = bpmMatch[1].trim();
                // Support tmp*2/3*4 syntax where tmp is Ableton tempo, or regular number*2/3*4
                const exprResult = evaluateExpression(bpmStr.toLowerCase(), { tmp: currentAbletonTempo });
                if (exprResult !== null && !isNaN(exprResult) && exprResult > 0) {
                    bpm = exprResult;
                }
            }
            
            // Parse .sn(...)
            const snMatch = str.match(/\.sn\(([^)]+)\)/);
            if (snMatch) {
                const snStr = snMatch[1].trim();
                // Support sn*2/3*4 syntax where sn is Ableton signature numerator, or regular number*2/3*4
                const exprResult = evaluateExpression(snStr.toLowerCase(), { sn: currentAbletonSignatureNumerator });
                if (exprResult !== null && !isNaN(exprResult) && exprResult > 0) {
                    sn = Math.round(exprResult);
                }
            }
            
            // Parse .sd(...)
            const sdMatch = str.match(/\.sd\(([^)]+)\)/);
            if (sdMatch) {
                const sdStr = sdMatch[1].trim();
                // Support sd*2/3*4 syntax where sd is Ableton signature denominator, or regular number*2/3*4
                const exprResult = evaluateExpression(sdStr.toLowerCase(), { sd: currentAbletonSignatureDenominator });
                if (exprResult !== null && !isNaN(exprResult) && exprResult > 0) {
                    sd = Math.round(exprResult);
                }
            }
            
            return { cycleId, tempo: bpm, sn, sd };
        }
        
        // Update Ableton info display
        let currentBeatNumber = 0;
        let currentBarNumber = 0;
        let currentAbletonTempo = null; // Store current Ableton tempo for tmp*f syntax
        let currentAbletonSignatureNumerator = null; // Store for sn*f syntax
        let currentAbletonSignatureDenominator = null; // Store for sd*f syntax
        
        function updateAbletonInfo(bpm, numerator, denominator) {
            // Store tempo for tmp*f syntax support
            if (bpm !== null && bpm !== undefined) {
                currentAbletonTempo = bpm;
            }
            // Store signature for sn*f and sd*f syntax support
            if (numerator !== null && numerator !== undefined) {
                currentAbletonSignatureNumerator = numerator;
            }
            if (denominator !== null && denominator !== undefined) {
                currentAbletonSignatureDenominator = denominator;
            }
            const bpmDisplay = document.getElementById('bpmDisplay');
            const signatureDisplay = document.getElementById('signatureDisplay');
            
            if (bpm !== null && bpm !== undefined) {
                bpmDisplay.textContent = `BPM: ${Math.round(bpm)}`;
            } else {
                bpmDisplay.textContent = 'BPM: --';
            }
            
            if (numerator !== null && numerator !== undefined && denominator !== null && denominator !== undefined) {
                signatureDisplay.textContent = `Signature: ${numerator}/${denominator}`;
                updateBeatSequencer(numerator);
            } else {
                signatureDisplay.textContent = 'Signature: --/--';
            }
        }
        
        // Create/update beat sequencer circles
        function updateBeatSequencer(beatsPerBar) {
            const sequencer = document.getElementById('beatSequencer');
            sequencer.innerHTML = '';
            
            for (let i = 1; i <= beatsPerBar; i++) {
                const circle = document.createElement('div');
                circle.className = 'beatCircle';
                circle.id = `beat-${i}`;
                sequencer.appendChild(circle);
            }
            
            // Update active beat if we have current beat info
            if (currentBeatNumber > 0) {
                updateBeatIndicator(currentBeatNumber, currentBarNumber);
            }
        }
        
        // Update which beat circle is active
        function updateBeatIndicator(beatNumber, barNumber) {
            currentBeatNumber = beatNumber;
            currentBarNumber = barNumber || 0;
            
            // Remove active class from all circles
            document.querySelectorAll('.beatCircle').forEach(circle => {
                circle.classList.remove('active');
            });
            
            // Add active class to current beat
            const activeCircle = document.getElementById(`beat-${beatNumber}`);
            if (activeCircle) {
                activeCircle.classList.add('active');
            }
        }
        
        // Helper function to send messages with connection check
        function sendToServer(data) {
            if (ws && ws.readyState === WebSocket.OPEN) {
                ws.send(JSON.stringify(data));
            } else {
                console.warn('WebSocket not connected, message queued:', data);
                // Optionally queue messages for when connection is restored
                // For now, just log a warning
                statusEl.textContent = 'Not Connected - Retrying...';
                statusEl.className = 'status disconnected';
            }
        }
        
        // Focus textarea on load
        window.addEventListener('load', () => {
            commandArea.focus();
        });
        
        // Cleanup on page unload
        window.addEventListener('beforeunload', () => {
            if (reconnectTimeout) {
                clearTimeout(reconnectTimeout);
            }
            if (ws) {
                ws.onclose = null; // Prevent reconnect on manual close
                ws.close();
            }
        });
    </script>
</body>
</html>


