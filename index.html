<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ALiCA - Command Interface</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Courier New', monospace;
            background: #1a1a1a;
            color: #e0e0e0;
            height: 100vh;
            overflow: hidden;
        }
        
        #commandArea {
            width: 100%;
            height: 100vh;
            padding: 20px;
            background: #0f0f0f;
            border: none;
            color: #e0e0e0;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            line-height: 1.6;
            resize: none;
            outline: none;
            tab-size: 2;
            white-space: pre;
            overflow-wrap: normal;
            overflow-x: auto;
        }
        
        #commandArea::placeholder {
            color: #666;
        }
        
        #status {
            position: fixed;
            top: 10px;
            right: 10px;
            padding: 8px 16px;
            border-radius: 4px;
            font-size: 12px;
            font-weight: bold;
            z-index: 1000;
            background: #333;
            border: 1px solid #555;
        }
        
        #status.connected {
            background: #2d5016;
            border-color: #4a7c2a;
            color: #a5d97a;
        }
        
        #status.disconnected {
            background: #501616;
            border-color: #7c2a2a;
            color: #d97a7a;
        }
        
        #hint {
            position: fixed;
            bottom: 10px;
            left: 10px;
            padding: 8px 12px;
            background: rgba(0, 0, 0, 0.7);
            border-radius: 4px;
            font-size: 11px;
            color: #888;
            z-index: 1000;
        }
        
        #abletonInfo {
            position: fixed;
            top: 10px;
            left: 10px;
            padding: 8px 16px;
            border-radius: 4px;
            font-size: 13px;
            font-weight: bold;
            z-index: 1000;
            background: #1a1a1a;
            border: 1px solid #444;
            color: #e0e0e0;
            display: flex;
            align-items: center;
            gap: 20px;
        }
        
        #bpmDisplay {
            color: #4a9eff;
        }
        
        #signatureDisplay {
            color: #9c27b0;
        }
        
        #beatSequencer {
            display: flex;
            gap: 6px;
            align-items: center;
        }
        
        .beatCircle {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: #444;
            border: 1px solid #666;
            transition: all 0.1s ease;
        }
        
        .beatCircle.active {
            background: #4a9eff;
            box-shadow: 0 0 8px #4a9eff;
            border-color: #6bb5ff;
            transform: scale(1.2);
        }
    </style>
</head>
<body>
    <div id="status" class="disconnected">Disconnected</div>
    <div id="abletonInfo">
        <span id="bpmDisplay">BPM: --</span>
        <span id="signatureDisplay">Signature: --/--</span>
        <div id="beatSequencer"></div>
    </div>
    <div id="hint">
        <strong>Shortcuts:</strong> Ctrl+S (queue cycle), Ctrl+Enter (queue track), Ctrl+Alt+S (play cycle), Ctrl+Alt+Enter (play track)<br>
        For Enter: no Shift = current track, + Shift = selected lines
    </div>
    <textarea id="commandArea" placeholder="Enter ALiCA commands here...&#10;&#10;Examples:&#10;t(mainLoop).bpm(80).sn(4).sd(8).play([n(<c3,e3,g3>)].c(1) [a(7).from(127).to(0)].c(1))&#10;&#10;playCycle('t(example).bpm(120).sn(4).sd(4).play([n(c3) n(c3)].c(1))')&#10;playTrack('t(test).bpm(100).sn(4).sd(4).play([a(7).from(0).to(127)].c(1))')"></textarea>

    <script>
        let ws = null;
        let reconnectTimeout = null;
        let reconnectAttempts = 0;
        const maxReconnectAttempts = Infinity; // Keep trying forever
        const reconnectDelay = 3000; // Start with 3 seconds
        const maxReconnectDelay = 30000; // Max 30 seconds
        const statusEl = document.getElementById('status');
        const commandArea = document.getElementById('commandArea');
        
        function connect() {
            // Clear any existing reconnect timeout
            if (reconnectTimeout) {
                clearTimeout(reconnectTimeout);
                reconnectTimeout = null;
            }
            
            // Close existing connection if any
            if (ws) {
                ws.onclose = null; // Prevent infinite loop
                ws.close();
            }
            
            try {
                ws = new WebSocket(`ws://localhost:4254`);
                
                ws.onopen = () => {
                    statusEl.textContent = 'Connected';
                    statusEl.className = 'status connected';
                    reconnectAttempts = 0; // Reset on successful connection
                    console.log('WebSocket connected');
                };
                
                ws.onclose = (event) => {
                    statusEl.textContent = 'Disconnected';
                    statusEl.className = 'status disconnected';
                    console.log('WebSocket disconnected', event.code, event.reason);
                    
                    // Attempt to reconnect (unless it was a clean close or manual close)
                    if (event.code !== 1000) { // 1000 = normal closure
                        scheduleReconnect();
                    }
                };
                
                ws.onerror = (error) => {
                    console.error('WebSocket error:', error);
                    statusEl.textContent = 'Error';
                    statusEl.className = 'status disconnected';
                };
                
                ws.onmessage = (event) => {
                    const data = JSON.parse(event.data);
                    console.log('Received:', data);
                    
                    // Handle BPM and signature updates
                    if (data.type === 'tempoAndSignature') {
                        updateAbletonInfo(data.tempo, data.signatureNumerator, data.signatureDenominator);
                        // Update sequencer when signature changes
                        if (data.signatureNumerator) {
                            updateBeatSequencer(data.signatureNumerator);
                        }
                    }
                    
                    // Handle beat updates
                    if (data.type === 'beat' && data.beatNumber !== undefined) {
                        updateBeatIndicator(data.beatNumber, data.bar);
                    }
                };
                
            } catch (error) {
                console.error('Failed to create WebSocket:', error);
                scheduleReconnect();
            }
        }
        
        function scheduleReconnect() {
            // Don't schedule if already scheduled
            if (reconnectTimeout) return;
            
            reconnectAttempts++;
            
            // Calculate delay with exponential backoff (capped at maxReconnectDelay)
            const delay = Math.min(reconnectDelay * Math.pow(1.5, reconnectAttempts - 1), maxReconnectDelay);
            
            statusEl.textContent = `Reconnecting... (attempt ${reconnectAttempts})`;
            console.log(`Scheduling reconnect in ${delay}ms (attempt ${reconnectAttempts})`);
            
            reconnectTimeout = setTimeout(() => {
                reconnectTimeout = null;
                connect();
            }, delay);
        }
        
        // Initial connection
        connect();
        
        // Handle keyboard shortcuts
        commandArea.addEventListener('keydown', (e) => {
            const isCtrl = e.ctrlKey || e.metaKey;
            const isShift = e.shiftKey;
            const isAlt = e.altKey;
            
            // Ctrl + S = queue playCycle for selected lines
            if (isCtrl && !isAlt && !isShift && e.key === 's') {
                e.preventDefault();
                queuePlayCycleForSelection();
            }
            // Ctrl + Shift + S = queue playCycle for current track
            else if (isCtrl && !isAlt && isShift && e.key === 'S') {
                e.preventDefault();
                queuePlayCycleForCurrentTrack();
            }
            // Ctrl + Enter = queue playTrack for current track (SWAPPED)
            else if (isCtrl && !isAlt && !isShift && e.key === 'Enter') {
                e.preventDefault();
                queuePlayTrackForCurrentTrack();
            }
            // Ctrl + Shift + Enter = queue playTrack for selected lines (SWAPPED)
            else if (isCtrl && !isAlt && isShift && e.key === 'Enter') {
                e.preventDefault();
                queuePlayTrackForSelection();
            }
            // Ctrl + Alt + S = playCycle for selected lines
            else if (isCtrl && isAlt && !isShift && e.key === 's') {
                e.preventDefault();
                playCycleForSelection();
            }
            // Ctrl + Alt + Shift + S = playCycle for current track
            else if (isCtrl && isAlt && isShift && e.key === 'S') {
                e.preventDefault();
                playCycleForCurrentTrack();
            }
            // Ctrl + Alt + Enter = playTrack for current track (SWAPPED)
            else if (isCtrl && isAlt && !isShift && e.key === 'Enter') {
                e.preventDefault();
                playTrackForCurrentTrack();
            }
            // Ctrl + Alt + Shift + Enter = playTrack for selected lines (SWAPPED)
            else if (isCtrl && isAlt && isShift && e.key === 'Enter') {
                e.preventDefault();
                playTrackForSelection();
            }
        });
        
        // Get selected text from textarea
        function getSelectedText() {
            const start = commandArea.selectionStart;
            const end = commandArea.selectionEnd;
            if (start === end) return null; // No selection
            return commandArea.value.substring(start, end);
        }
        
        // Get selected lines or line containing cursor
        function getSelectedLines() {
            const fullText = commandArea.value;
            const start = commandArea.selectionStart;
            const end = commandArea.selectionEnd;
            
            // Check if there's actual text selection (not just cursor position)
            const hasSelection = start !== end;
            
            if (hasSelection) {
                // Use actual selection boundaries
                let lineStart = start;
                let lineEnd = end;
                
                // Find start of first line containing selection
                while (lineStart > 0 && fullText[lineStart - 1] !== '\n') {
                    lineStart--;
                }
                
                // Find end of last line containing selection
                while (lineEnd < fullText.length && fullText[lineEnd] !== '\n') {
                    lineEnd++;
                }
                
                const selectedText = fullText.substring(lineStart, lineEnd);
                // Get all lines within selection, filtering empty and comments
                const lines = selectedText.split('\n').filter(line => {
                    const trimmed = line.trim();
                    return trimmed && !trimmed.startsWith('//');
                });
                
                if (lines.length === 0) return null;
                // Join all selected lines
                return lines.join(' ');
            } else {
                // No selection - use line containing cursor
                const cursorPos = start;
                let lineStart = cursorPos;
                let lineEnd = cursorPos;
                
                // Find start of line containing cursor
                while (lineStart > 0 && fullText[lineStart - 1] !== '\n') {
                    lineStart--;
                }
                
                // Find end of line containing cursor
                while (lineEnd < fullText.length && fullText[lineEnd] !== '\n') {
                    lineEnd++;
                }
                
                const lineText = fullText.substring(lineStart, lineEnd).trim();
                if (!lineText || lineText.startsWith('//')) return null;
                
                return lineText;
            }
        }
        
        // Find the t(...).play(...) wrapper that contains the cursor/selection
        function findCurrentTrack() {
            const fullText = commandArea.value;
            const cursorPos = commandArea.selectionStart;
            
            // Find the nearest t(...) before cursor
            let searchStart = 0;
            let bestMatch = null;
            let bestEnd = -1;
            
            while (true) {
                const tIndex = fullText.indexOf('t(', searchStart);
                if (tIndex === -1 || tIndex > cursorPos) break;
                
                // Find matching closing parenthesis for .play(...)
                let depth = 0;
                let pos = tIndex;
                let inPlay = false;
                let playStartPos = -1;
                
                while (pos < fullText.length) {
                    if (fullText.substring(pos).startsWith('.play(')) {
                        inPlay = true;
                        playStartPos = pos + 6; // Position after '.play('
                        pos += 6; // Skip '.play('
                        depth = 1;
                        continue;
                    }
                    
                    if (fullText[pos] === '(') depth++;
                    else if (fullText[pos] === ')') {
                        depth--;
                        if (inPlay && depth === 0) {
                            // Found complete t(...).play(...)
                            const endPos = pos + 1;
                            // Check if cursor is within this track
                            if (cursorPos >= tIndex && cursorPos <= endPos) {
                                bestMatch = fullText.substring(tIndex, endPos);
                                bestEnd = endPos;
                                break;
                            }
                            break;
                        }
                    }
                    pos++;
                }
                
                searchStart = tIndex + 2;
            }
            
            return bestMatch;
        }
        
        // Apply t() wrapper settings to a sequence string
        function applyWrapperSettings(sequenceStr, wrapperStr) {
            if (!wrapperStr || !wrapperStr.startsWith('t(')) {
                return sequenceStr; // No wrapper, return as-is
            }
            
            const parsed = parseMethodChain(wrapperStr);
            if (!parsed) return sequenceStr;
            
            // Extract cycleId and build new t() wrapper with sequence
            const match = wrapperStr.match(/^t\(([^)]+)\)/);
            if (!match) return sequenceStr;
            
            const cycleId = match[1];
            let result = `t(${cycleId})`;
            
            if (parsed.tempo !== null) result += `.bpm(${parsed.tempo})`;
            if (parsed.sn !== null) result += `.sn(${parsed.sn})`;
            if (parsed.sd !== null) result += `.sd(${parsed.sd})`;
            
            result += `.play(${sequenceStr})`;
            return result;
        }
        
        // Queue playCycle for selected lines
        function queuePlayCycleForSelection() {
            const selectedSeq = getSelectedLines();
            if (!selectedSeq) {
                console.warn('No valid sequence selected');
                return;
            }
            
            const wrapper = findCurrentTrack();
            const fullCommand = applyWrapperSettings(selectedSeq, wrapper);
            const parsed = parseMethodChain(fullCommand);
            
            sendToServer({
                action: 'addCycleToQueue',
                id: null,
                cycleStr: fullCommand,
                tempo: parsed?.tempo || null,
                signatureNumerator: parsed?.sn || null,
                signatureDenominator: parsed?.sd || null
            });
        }
        
        // Queue playCycle for current track
        function queuePlayCycleForCurrentTrack() {
            const track = findCurrentTrack();
            if (!track) {
                console.warn('No t() track found');
                return;
            }
            
            const parsed = parseMethodChain(track);
            sendToServer({
                action: 'addCycleToQueue',
                id: null,
                cycleStr: track,
                tempo: parsed?.tempo || null,
                signatureNumerator: parsed?.sn || null,
                signatureDenominator: parsed?.sd || null
            });
        }
        
        // Queue playTrack for selected lines
        function queuePlayTrackForSelection() {
            const selectedSeq = getSelectedLines();
            if (!selectedSeq) {
                console.warn('No valid sequence selected');
                return;
            }
            
            const wrapper = findCurrentTrack();
            const fullCommand = applyWrapperSettings(selectedSeq, wrapper);
            const parsed = parseMethodChain(fullCommand);
            
            sendToServer({
                action: 'addTrackToQueue',
                id: null,
                cycleStr: fullCommand,
                tempo: parsed?.tempo || null,
                signatureNumerator: parsed?.sn || null,
                signatureDenominator: parsed?.sd || null
            });
        }
        
        // Queue playTrack for current track
        function queuePlayTrackForCurrentTrack() {
            const track = findCurrentTrack();
            if (!track) {
                console.warn('No t() track found');
                return;
            }
            
            const parsed = parseMethodChain(track);
            sendToServer({
                action: 'addTrackToQueue',
                id: null,
                cycleStr: track,
                tempo: parsed?.tempo || null,
                signatureNumerator: parsed?.sn || null,
                signatureDenominator: parsed?.sd || null
            });
        }
        
        // Play playCycle for selected lines (immediate)
        function playCycleForSelection() {
            const selectedSeq = getSelectedLines();
            if (!selectedSeq) {
                console.warn('No valid sequence selected');
                return;
            }
            
            const wrapper = findCurrentTrack();
            const fullCommand = applyWrapperSettings(selectedSeq, wrapper);
            const parsed = parseMethodChain(fullCommand);
            
            sendToServer({
                action: 'playCycle',
                id: null,
                cycleStr: fullCommand,
                tempo: parsed?.tempo || null,
                signatureNumerator: parsed?.sn || null,
                signatureDenominator: parsed?.sd || null
            });
        }
        
        // Play playCycle for current track (immediate)
        function playCycleForCurrentTrack() {
            const track = findCurrentTrack();
            if (!track) {
                console.warn('No t() track found');
                return;
            }
            
            const parsed = parseMethodChain(track);
            sendToServer({
                action: 'playCycle',
                id: null,
                cycleStr: track,
                tempo: parsed?.tempo || null,
                signatureNumerator: parsed?.sn || null,
                signatureDenominator: parsed?.sd || null
            });
        }
        
        // Play playTrack for selected lines (immediate)
        function playTrackForSelection() {
            const selectedSeq = getSelectedLines();
            if (!selectedSeq) {
                console.warn('No valid sequence selected');
                return;
            }
            
            const wrapper = findCurrentTrack();
            const fullCommand = applyWrapperSettings(selectedSeq, wrapper);
            const parsed = parseMethodChain(fullCommand);
            
            sendToServer({
                action: 'playTrack',
                id: null,
                cycleStr: fullCommand,
                tempo: parsed?.tempo || null,
                signatureNumerator: parsed?.sn || null,
                signatureDenominator: parsed?.sd || null
            });
        }
        
        // Play playTrack for current track (immediate)
        function playTrackForCurrentTrack() {
            const track = findCurrentTrack();
            if (!track) {
                console.warn('No t() track found');
                return;
            }
            
            const parsed = parseMethodChain(track);
            sendToServer({
                action: 'playTrack',
                id: null,
                cycleStr: track,
                tempo: parsed?.tempo || null,
                signatureNumerator: parsed?.sn || null,
                signatureDenominator: parsed?.sd || null
            });
        }
        
        // Join multi-line commands by tracking parentheses depth
        function joinMultiLineCommand(text) {
            const lines = text.split('\n');
            const commands = [];
            let currentCommand = '';
            let parenDepth = 0;
            let inString = false;
            let stringChar = null;
            
            for (const line of lines) {
                const trimmed = line.trim();
                
                // Skip empty lines and comments (but only when not in the middle of a command)
                if (!trimmed || trimmed.startsWith('//')) {
                    if (currentCommand && parenDepth === 0) {
                        commands.push(currentCommand.trim());
                        currentCommand = '';
                    }
                    continue;
                }
                
                // Track parentheses and strings across the entire line
                for (let i = 0; i < line.length; i++) {
                    const char = line[i];
                    const prevChar = i > 0 ? line[i-1] : null;
                    
                    if (!inString && (char === '"' || char === "'")) {
                        inString = true;
                        stringChar = char;
                    } else if (inString && char === stringChar && prevChar !== '\\') {
                        inString = false;
                        stringChar = null;
                    } else if (!inString) {
                        if (char === '(') parenDepth++;
                        else if (char === ')') parenDepth--;
                    }
                }
                
                // Add line to current command
                if (currentCommand) {
                    currentCommand += ' ' + trimmed;
                } else {
                    currentCommand = trimmed;
                }
                
                // If we've closed all parentheses and not in a string, command is complete
                if (parenDepth === 0 && !inString && currentCommand) {
                    commands.push(currentCommand.trim());
                    currentCommand = '';
                    parenDepth = 0;
                }
            }
            
            // Add any remaining command
            if (currentCommand.trim()) {
                commands.push(currentCommand.trim());
            }
            
            return commands.filter(cmd => cmd.length > 0);
        }
        
        // Split text into individual commands (now simplified since joinMultiLineCommand handles it)
        function splitCommands(text) {
            // The joinMultiLineCommand already returns an array of commands
            // But if text wasn't processed, split by newlines and filter
            const commands = Array.isArray(text) ? text : [text];
            return commands.filter(cmd => cmd.trim() && !cmd.trim().startsWith('//'));
        }
        
        // Simple parser for new syntax (client-side helper)
        function parseMethodChain(str) {
            if (!str || !str.trim().startsWith('t(')) return null;
            
            const match = str.match(/^t\(([^)]+)\)/);
            if (!match) return null;
            
            const cycleId = match[1].trim();
            let bpm = null, sn = null, sd = null;
            
            // Parse .bpm(...)
            const bpmMatch = str.match(/\.bpm\(([^)]+)\)/);
            if (bpmMatch) {
                const val = parseFloat(bpmMatch[1]);
                if (!isNaN(val) && val > 0) bpm = val;
            }
            
            // Parse .sn(...)
            const snMatch = str.match(/\.sn\(([^)]+)\)/);
            if (snMatch) {
                const val = parseFloat(snMatch[1]);
                if (!isNaN(val) && val > 0) sn = Math.round(val);
            }
            
            // Parse .sd(...)
            const sdMatch = str.match(/\.sd\(([^)]+)\)/);
            if (sdMatch) {
                const val = parseFloat(sdMatch[1]);
                if (!isNaN(val) && val > 0) sd = Math.round(val);
            }
            
            return { cycleId, tempo: bpm, sn, sd };
        }
        
        // Update Ableton info display
        let currentBeatNumber = 0;
        let currentBarNumber = 0;
        
        function updateAbletonInfo(bpm, numerator, denominator) {
            const bpmDisplay = document.getElementById('bpmDisplay');
            const signatureDisplay = document.getElementById('signatureDisplay');
            
            if (bpm !== null && bpm !== undefined) {
                bpmDisplay.textContent = `BPM: ${Math.round(bpm)}`;
            } else {
                bpmDisplay.textContent = 'BPM: --';
            }
            
            if (numerator !== null && numerator !== undefined && denominator !== null && denominator !== undefined) {
                signatureDisplay.textContent = `Signature: ${numerator}/${denominator}`;
                updateBeatSequencer(numerator);
            } else {
                signatureDisplay.textContent = 'Signature: --/--';
            }
        }
        
        // Create/update beat sequencer circles
        function updateBeatSequencer(beatsPerBar) {
            const sequencer = document.getElementById('beatSequencer');
            sequencer.innerHTML = '';
            
            for (let i = 1; i <= beatsPerBar; i++) {
                const circle = document.createElement('div');
                circle.className = 'beatCircle';
                circle.id = `beat-${i}`;
                sequencer.appendChild(circle);
            }
            
            // Update active beat if we have current beat info
            if (currentBeatNumber > 0) {
                updateBeatIndicator(currentBeatNumber, currentBarNumber);
            }
        }
        
        // Update which beat circle is active
        function updateBeatIndicator(beatNumber, barNumber) {
            currentBeatNumber = beatNumber;
            currentBarNumber = barNumber || 0;
            
            // Remove active class from all circles
            document.querySelectorAll('.beatCircle').forEach(circle => {
                circle.classList.remove('active');
            });
            
            // Add active class to current beat
            const activeCircle = document.getElementById(`beat-${beatNumber}`);
            if (activeCircle) {
                activeCircle.classList.add('active');
            }
        }
        
        // Helper function to send messages with connection check
        function sendToServer(data) {
            if (ws && ws.readyState === WebSocket.OPEN) {
                ws.send(JSON.stringify(data));
            } else {
                console.warn('WebSocket not connected, message queued:', data);
                // Optionally queue messages for when connection is restored
                // For now, just log a warning
                statusEl.textContent = 'Not Connected - Retrying...';
                statusEl.className = 'status disconnected';
            }
        }
        
        // Focus textarea on load
        window.addEventListener('load', () => {
            commandArea.focus();
        });
        
        // Cleanup on page unload
        window.addEventListener('beforeunload', () => {
            if (reconnectTimeout) {
                clearTimeout(reconnectTimeout);
            }
            if (ws) {
                ws.onclose = null; // Prevent reconnect on manual close
                ws.close();
            }
        });
    </script>
</body>
</html>

