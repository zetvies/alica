<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ALiCA - Command Interface</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Courier New', monospace;
            background: #1a1a1a;
            color: #e0e0e0;
            height: 100vh;
            overflow: hidden;
        }
        
        #commandArea {
            width: 100%;
            height: 100vh;
            padding: 20px;
            background: #0f0f0f;
            border: none;
            color: #e0e0e0;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            line-height: 1.6;
            resize: none;
            outline: none;
            tab-size: 2;
            white-space: pre;
            overflow-wrap: normal;
            overflow-x: auto;
        }
        
        #commandArea::placeholder {
            color: #666;
        }
        
        #status {
            position: fixed;
            top: 10px;
            right: 10px;
            padding: 8px 16px;
            border-radius: 4px;
            font-size: 12px;
            font-weight: bold;
            z-index: 1000;
            background: #333;
            border: 1px solid #555;
        }
        
        #status.connected {
            background: #2d5016;
            border-color: #4a7c2a;
            color: #a5d97a;
        }
        
        #status.disconnected {
            background: #501616;
            border-color: #7c2a2a;
            color: #d97a7a;
        }
        
        #hint {
            position: fixed;
            bottom: 10px;
            left: 10px;
            padding: 8px 12px;
            background: rgba(0, 0, 0, 0.7);
            border-radius: 4px;
            font-size: 11px;
            color: #888;
            z-index: 1000;
        }
        
        #abletonInfo {
            position: fixed;
            top: 10px;
            left: 10px;
            padding: 8px 16px;
            border-radius: 4px;
            font-size: 13px;
            font-weight: bold;
            z-index: 1000;
            background: #1a1a1a;
            border: 1px solid #444;
            color: #e0e0e0;
            display: flex;
            align-items: center;
            gap: 20px;
        }
        
        #bpmDisplay {
            color: #4a9eff;
        }
        
        #signatureDisplay {
            color: #9c27b0;
        }
        
        #beatSequencer {
            display: flex;
            gap: 6px;
            align-items: center;
        }
        
        .beatCircle {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: #444;
            border: 1px solid #666;
            transition: all 0.1s ease;
        }
        
        .beatCircle.active {
            background: #4a9eff;
            box-shadow: 0 0 8px #4a9eff;
            border-color: #6bb5ff;
            transform: scale(1.2);
        }
    </style>
</head>
<body>
    <div id="status" class="disconnected">Disconnected</div>
    <div id="abletonInfo">
        <span id="bpmDisplay">BPM: --</span>
        <span id="signatureDisplay">Signature: --/--</span>
        <div id="beatSequencer"></div>
    </div>
    <div id="hint">Press Ctrl+Enter to execute command</div>
    <textarea id="commandArea" placeholder="Enter ALiCA commands here...&#10;&#10;Examples:&#10;t(mainLoop).bpm(80).sn(4).sd(8).play([n(<c3,e3,g3>)].c(1) [a(7).from(127).to(0)].c(1))&#10;&#10;playCycle('t(example).bpm(120).sn(4).sd(4).play([n(c3) n(c3)].c(1))')&#10;playTrack('t(test).bpm(100).sn(4).sd(4).play([a(7).from(0).to(127)].c(1))')"></textarea>

    <script>
        let ws = null;
        let reconnectTimeout = null;
        let reconnectAttempts = 0;
        const maxReconnectAttempts = Infinity; // Keep trying forever
        const reconnectDelay = 3000; // Start with 3 seconds
        const maxReconnectDelay = 30000; // Max 30 seconds
        const statusEl = document.getElementById('status');
        const commandArea = document.getElementById('commandArea');
        
        function connect() {
            // Clear any existing reconnect timeout
            if (reconnectTimeout) {
                clearTimeout(reconnectTimeout);
                reconnectTimeout = null;
            }
            
            // Close existing connection if any
            if (ws) {
                ws.onclose = null; // Prevent infinite loop
                ws.close();
            }
            
            try {
                ws = new WebSocket(`ws://localhost:4254`);
                
                ws.onopen = () => {
                    statusEl.textContent = 'Connected';
                    statusEl.className = 'status connected';
                    reconnectAttempts = 0; // Reset on successful connection
                    console.log('WebSocket connected');
                };
                
                ws.onclose = (event) => {
                    statusEl.textContent = 'Disconnected';
                    statusEl.className = 'status disconnected';
                    console.log('WebSocket disconnected', event.code, event.reason);
                    
                    // Attempt to reconnect (unless it was a clean close or manual close)
                    if (event.code !== 1000) { // 1000 = normal closure
                        scheduleReconnect();
                    }
                };
                
                ws.onerror = (error) => {
                    console.error('WebSocket error:', error);
                    statusEl.textContent = 'Error';
                    statusEl.className = 'status disconnected';
                };
                
                ws.onmessage = (event) => {
                    const data = JSON.parse(event.data);
                    console.log('Received:', data);
                    
                    // Handle BPM and signature updates
                    if (data.type === 'tempoAndSignature') {
                        updateAbletonInfo(data.tempo, data.signatureNumerator, data.signatureDenominator);
                        // Update sequencer when signature changes
                        if (data.signatureNumerator) {
                            updateBeatSequencer(data.signatureNumerator);
                        }
                    }
                    
                    // Handle beat updates
                    if (data.type === 'beat' && data.beatNumber !== undefined) {
                        updateBeatIndicator(data.beatNumber, data.bar);
                    }
                };
                
            } catch (error) {
                console.error('Failed to create WebSocket:', error);
                scheduleReconnect();
            }
        }
        
        function scheduleReconnect() {
            // Don't schedule if already scheduled
            if (reconnectTimeout) return;
            
            reconnectAttempts++;
            
            // Calculate delay with exponential backoff (capped at maxReconnectDelay)
            const delay = Math.min(reconnectDelay * Math.pow(1.5, reconnectAttempts - 1), maxReconnectDelay);
            
            statusEl.textContent = `Reconnecting... (attempt ${reconnectAttempts})`;
            console.log(`Scheduling reconnect in ${delay}ms (attempt ${reconnectAttempts})`);
            
            reconnectTimeout = setTimeout(() => {
                reconnectTimeout = null;
                connect();
            }, delay);
        }
        
        // Initial connection
        connect();
        
        // Handle keyboard shortcuts
        commandArea.addEventListener('keydown', (e) => {
            // Ctrl+Enter or Cmd+Enter to execute
            if ((e.ctrlKey || e.metaKey) && e.key === 'Enter') {
                e.preventDefault();
                executeCommand();
            }
        });
        
        function executeCommand() {
            const text = commandArea.value.trim();
            if (!text) return;
            
            // First, try to join multi-line commands
            // Look for commands that span multiple lines (especially t(...).play(...))
            const commands = joinMultiLineCommand(text);
            
            // Process each complete command
            commands.forEach(command => {
                const trimmed = command.trim();
                if (!trimmed || trimmed.startsWith('//')) return; // Skip empty lines and comments
                
                // Check if it's a function call pattern
                if (trimmed.startsWith('playCycle(') || trimmed.startsWith('playTrack(')) {
                    // Extract the string argument (may span multiple lines)
                    const match = trimmed.match(/(playCycle|playTrack)\s*\(\s*['"](.+?)['"]\s*\)/s);
                    if (match) {
                        const action = match[1] === 'playCycle' ? 'playCycle' : 'playTrack';
                        const cycleStr = match[2];
                        
                        // Check if new syntax is used
                        const parsed = parseMethodChain(cycleStr);
                        
                        sendToServer({
                            action: action,
                            id: null, // Let server extract from t(cycleId)
                            cycleStr: cycleStr,
                            tempo: parsed?.tempo || null,
                            signatureNumerator: parsed?.sn || null,
                            signatureDenominator: parsed?.sd || null
                        });
                    }
                } else if (trimmed.startsWith('t(')) {
                    // Direct new syntax - default to addCycleToQueue
                    // Don't send id - let server extract it from t(cycleId)
                    const parsed = parseMethodChain(trimmed);
                    
                    sendToServer({
                        action: 'addCycleToQueue',
                        id: null, // Let server extract from t(cycleId)
                        cycleStr: trimmed,
                        tempo: parsed?.tempo || null,
                        signatureNumerator: parsed?.sn || null,
                        signatureDenominator: parsed?.sd || null
                    });
                } else {
                    // Legacy format or unknown - default to addCycleToQueue
                    sendToServer({
                        action: 'addCycleToQueue',
                        id: null,
                        cycleStr: trimmed,
                        tempo: null,
                        signatureNumerator: null,
                        signatureDenominator: null
                    });
                }
            });
        }
        
        // Join multi-line commands by tracking parentheses depth
        function joinMultiLineCommand(text) {
            const lines = text.split('\n');
            const commands = [];
            let currentCommand = '';
            let parenDepth = 0;
            let inString = false;
            let stringChar = null;
            
            for (const line of lines) {
                const trimmed = line.trim();
                
                // Skip empty lines and comments (but only when not in the middle of a command)
                if (!trimmed || trimmed.startsWith('//')) {
                    if (currentCommand && parenDepth === 0) {
                        commands.push(currentCommand.trim());
                        currentCommand = '';
                    }
                    continue;
                }
                
                // Track parentheses and strings across the entire line
                for (let i = 0; i < line.length; i++) {
                    const char = line[i];
                    const prevChar = i > 0 ? line[i-1] : null;
                    
                    if (!inString && (char === '"' || char === "'")) {
                        inString = true;
                        stringChar = char;
                    } else if (inString && char === stringChar && prevChar !== '\\') {
                        inString = false;
                        stringChar = null;
                    } else if (!inString) {
                        if (char === '(') parenDepth++;
                        else if (char === ')') parenDepth--;
                    }
                }
                
                // Add line to current command
                if (currentCommand) {
                    currentCommand += ' ' + trimmed;
                } else {
                    currentCommand = trimmed;
                }
                
                // If we've closed all parentheses and not in a string, command is complete
                if (parenDepth === 0 && !inString && currentCommand) {
                    commands.push(currentCommand.trim());
                    currentCommand = '';
                    parenDepth = 0;
                }
            }
            
            // Add any remaining command
            if (currentCommand.trim()) {
                commands.push(currentCommand.trim());
            }
            
            return commands.filter(cmd => cmd.length > 0);
        }
        
        // Split text into individual commands (now simplified since joinMultiLineCommand handles it)
        function splitCommands(text) {
            // The joinMultiLineCommand already returns an array of commands
            // But if text wasn't processed, split by newlines and filter
            const commands = Array.isArray(text) ? text : [text];
            return commands.filter(cmd => cmd.trim() && !cmd.trim().startsWith('//'));
        }
        
        // Simple parser for new syntax (client-side helper)
        function parseMethodChain(str) {
            if (!str || !str.trim().startsWith('t(')) return null;
            
            const match = str.match(/^t\(([^)]+)\)/);
            if (!match) return null;
            
            const cycleId = match[1].trim();
            let bpm = null, sn = null, sd = null;
            
            // Parse .bpm(...)
            const bpmMatch = str.match(/\.bpm\(([^)]+)\)/);
            if (bpmMatch) {
                const val = parseFloat(bpmMatch[1]);
                if (!isNaN(val) && val > 0) bpm = val;
            }
            
            // Parse .sn(...)
            const snMatch = str.match(/\.sn\(([^)]+)\)/);
            if (snMatch) {
                const val = parseFloat(snMatch[1]);
                if (!isNaN(val) && val > 0) sn = Math.round(val);
            }
            
            // Parse .sd(...)
            const sdMatch = str.match(/\.sd\(([^)]+)\)/);
            if (sdMatch) {
                const val = parseFloat(sdMatch[1]);
                if (!isNaN(val) && val > 0) sd = Math.round(val);
            }
            
            return { cycleId, tempo: bpm, sn, sd };
        }
        
        // Update Ableton info display
        let currentBeatNumber = 0;
        let currentBarNumber = 0;
        
        function updateAbletonInfo(bpm, numerator, denominator) {
            const bpmDisplay = document.getElementById('bpmDisplay');
            const signatureDisplay = document.getElementById('signatureDisplay');
            
            if (bpm !== null && bpm !== undefined) {
                bpmDisplay.textContent = `BPM: ${Math.round(bpm)}`;
            } else {
                bpmDisplay.textContent = 'BPM: --';
            }
            
            if (numerator !== null && numerator !== undefined && denominator !== null && denominator !== undefined) {
                signatureDisplay.textContent = `Signature: ${numerator}/${denominator}`;
                updateBeatSequencer(numerator);
            } else {
                signatureDisplay.textContent = 'Signature: --/--';
            }
        }
        
        // Create/update beat sequencer circles
        function updateBeatSequencer(beatsPerBar) {
            const sequencer = document.getElementById('beatSequencer');
            sequencer.innerHTML = '';
            
            for (let i = 1; i <= beatsPerBar; i++) {
                const circle = document.createElement('div');
                circle.className = 'beatCircle';
                circle.id = `beat-${i}`;
                sequencer.appendChild(circle);
            }
            
            // Update active beat if we have current beat info
            if (currentBeatNumber > 0) {
                updateBeatIndicator(currentBeatNumber, currentBarNumber);
            }
        }
        
        // Update which beat circle is active
        function updateBeatIndicator(beatNumber, barNumber) {
            currentBeatNumber = beatNumber;
            currentBarNumber = barNumber || 0;
            
            // Remove active class from all circles
            document.querySelectorAll('.beatCircle').forEach(circle => {
                circle.classList.remove('active');
            });
            
            // Add active class to current beat
            const activeCircle = document.getElementById(`beat-${beatNumber}`);
            if (activeCircle) {
                activeCircle.classList.add('active');
            }
        }
        
        // Helper function to send messages with connection check
        function sendToServer(data) {
            if (ws && ws.readyState === WebSocket.OPEN) {
                ws.send(JSON.stringify(data));
            } else {
                console.warn('WebSocket not connected, message queued:', data);
                // Optionally queue messages for when connection is restored
                // For now, just log a warning
                statusEl.textContent = 'Not Connected - Retrying...';
                statusEl.className = 'status disconnected';
            }
        }
        
        // Focus textarea on load
        window.addEventListener('load', () => {
            commandArea.focus();
        });
        
        // Cleanup on page unload
        window.addEventListener('beforeunload', () => {
            if (reconnectTimeout) {
                clearTimeout(reconnectTimeout);
            }
            if (ws) {
                ws.onclose = null; // Prevent reconnect on manual close
                ws.close();
            }
        });
    </script>
</body>
</html>

