<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ALiCA - Command Interface</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Courier New', monospace;
            background: #1a1a1a;
            color: #e0e0e0;
            height: 100vh;
            overflow: hidden;
        }
        
        /* Custom scrollbar styling */
        ::-webkit-scrollbar {
            width: 12px;
            height: 12px;
        }
        
        ::-webkit-scrollbar-track {
            background: #1a1a1a;
            border-left: 1px solid #333;
        }
        
        ::-webkit-scrollbar-thumb {
            background: #444;
            border-radius: 6px;
            border: 2px solid #1a1a1a;
        }
        
        ::-webkit-scrollbar-thumb:hover {
            background: #555;
        }
        
        ::-webkit-scrollbar-thumb:active {
            background: #666;
        }
        
        /* Firefox scrollbar */
        #commandArea,
        #highlightOverlay {
            scrollbar-width: thin;
            scrollbar-color: #444 #1a1a1a;
        }
        
        #editorContainer {
            position: relative;
            width: 100%;
            margin-top: 50px; /* Account for header */
            height: calc(100vh - 50px);
        }
        
        #commandArea {
            width: 100%;
            height: 100%;
            padding: 20px;
            background: transparent;
            border: none;
            color: transparent; /* Make text transparent - overlay shows the text */
            font-family: 'Courier New', monospace;
            font-size: 14px;
            line-height: 1.6;
            resize: none;
            outline: none;
            tab-size: 2;
            white-space: pre;
            overflow-wrap: normal;
            overflow-x: auto;
            position: relative;
            z-index: 2;
            caret-color: #e0e0e0;
        }
        
        #commandArea::selection {
            background: rgba(100, 150, 255, 0.3);
        }
        
        #highlightOverlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            padding: 20px;
            margin: 0;
            background: #0f0f0f;
            box-sizing: border-box;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            line-height: 1.6;
            white-space: pre;
            overflow-wrap: normal;
            overflow-x: auto;
            overflow-y: hidden;
            pointer-events: none;
            z-index: 1;
            tab-size: 2;
            color: #e0e0e0; /* Normal text color */
        }
        
        #highlightOverlay .char {
            color: #e0e0e0;
        }
        
        #highlightOverlay .bracket {
            font-weight: bold;
        }
        
        #highlightOverlay .error {
            color: #ff6b6b; /* Red for syntax errors */
            background: rgba(255, 107, 107, 0.1);
        }
        
        /* Track-level brackets (t(), .play(), .bpm(), etc.) */
        .bracket-track-0 { color: #ff6b6b; } /* Red */
        .bracket-track-1 { color: #feca57; } /* Orange Yellow */
        .bracket-track-2 { color: #ff9ff3; } /* Magenta */
        .bracket-track-3 { color: #a29bfe; } /* Purple */
        
        /* Sequence-level brackets ([...], .c(), .ds(), etc.) */
        .bracket-seq-0 { color: #00d2d3; } /* Teal */
        .bracket-seq-1 { color: #fd79a8; } /* Hot Pink */
        .bracket-seq-2 { color: #fdcb6e; } /* Golden Yellow */
        .bracket-seq-3 { color: #55efc4; } /* Mint */
        
        #commandArea::placeholder {
            color: #666;
        }
        
        #header {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            height: 50px;
            background: #1a1a1a;
            border-bottom: 1px solid #444;
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 20px;
            z-index: 1000;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
        }
        
        #headerLeft {
            display: flex;
            align-items: center;
            font-size: 20px;
            font-weight: bold;
            color: #e0e0e0;
        }
        
        #headerLeft .brand {
            font-size: 20px;
        }
        
        #headerLeft .byline {
            font-size: 11px;
            color: #888;
            margin-left: 6px;
            font-weight: normal;
        }
        
        #headerMiddle {
            display: flex;
            align-items: center;
            gap: 20px;
            font-size: 13px;
            font-weight: bold;
            color: #e0e0e0;
        }
        
        #headerRight {
            display: flex;
            align-items: center;
        }
        
        #status {
            padding: 8px 16px;
            border-radius: 4px;
            font-size: 12px;
            font-weight: bold;
            background: #333;
            border: 1px solid #555;
        }
        
        #status.connected {
            background: #2d5016;
            border-color: #4a7c2a;
            color: #a5d97a;
        }
        
        #status.disconnected {
            background: #501616;
            border-color: #7c2a2a;
            color: #d97a7a;
        }
        
        #hint {
            position: fixed;
            bottom: 10px;
            left: 10px;
            padding: 8px 12px;
            background: rgba(0, 0, 0, 0.7);
            border-radius: 4px;
            font-size: 11px;
            color: #888;
            z-index: 1000;
        }
        
        #bpmDisplay {
            color: #4a9eff;
        }
        
        #signatureDisplay {
            color: #9c27b0;
        }
        
        #beatSequencer {
            display: flex;
            gap: 6px;
            align-items: center;
        }
        
        .beatCircle {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: #444;
            border: 1px solid #666;
            transition: all 0.1s ease;
        }
        
        .beatCircle.active {
            background: #4a9eff;
            box-shadow: 0 0 8px #4a9eff;
            border-color: #6bb5ff;
            transform: scale(1.2);
        }
    </style>
</head>
<body>
    <div id="header">
        <div id="headerLeft">
            <span class="brand">ALiCA</span>
            <span class="byline">by Zetvies</span>
        </div>
        <div id="headerMiddle">
            <span id="bpmDisplay">BPM: --</span>
            <span id="signatureDisplay">Signature: --/--</span>
            <div id="beatSequencer"></div>
        </div>
        <div id="headerRight">
            <div id="status" class="disconnected">Disconnected</div>
        </div>
        </div>
        <div id="hint">
        <strong>Shortcuts:</strong> Ctrl+/ (toggle comment), Ctrl+H (clear all cycles), Ctrl+S (save/queue cycle), Ctrl+Enter (queue track), Ctrl+Alt+S (play cycle), Ctrl+Alt+Enter (play track)<br>
        For Enter: no Shift = current track, + Shift = selected lines
        </div>
    <div id="editorContainer">
        <div id="highlightOverlay"></div>
        <textarea id="commandArea" placeholder="Enter ALiCA commands here...&#10;&#10;Examples:&#10;t(mainLoop).bpm(80).sn(4).sd(8).play([n(<c3,e3,g3>)].c(1) [a(7).from(127).to(0)].c(1))&#10;&#10;playCycle('t(example).bpm(120).sn(4).sd(4).play([n(c3) n(c3)].c(1))')&#10;playTrack('t(test).bpm(100).sn(4).sd(4).play([a(7).from(0).to(127)].c(1))')"></textarea>
    </div>

    <script>
        let ws = null;
        let reconnectTimeout = null;
        let reconnectAttempts = 0;
        const maxReconnectAttempts = Infinity; // Keep trying forever
        const reconnectDelay = 3000; // Start with 3 seconds
        const maxReconnectDelay = 30000; // Max 30 seconds
        const statusEl = document.getElementById('status');
        const commandArea = document.getElementById('commandArea');
        
        // Initialize highlighting immediately if elements exist
        if (commandArea) {
            // Wait a bit for overlay to be ready
            setTimeout(() => {
                const overlay = document.getElementById('highlightOverlay');
                if (overlay) {
                    highlightOverlay = overlay;
                    highlightBrackets();
                }
            }, 50);
        }
        
        function connect() {
            // Clear any existing reconnect timeout
            if (reconnectTimeout) {
                clearTimeout(reconnectTimeout);
                reconnectTimeout = null;
            }
            
            // Close existing connection if any
            if (ws) {
                ws.onclose = null; // Prevent infinite loop
                ws.close();
            }
            
            try {
                ws = new WebSocket(`ws://localhost:4254`);
        
        ws.onopen = () => {
            statusEl.textContent = 'Connected';
            statusEl.className = 'status connected';
                    reconnectAttempts = 0; // Reset on successful connection
            console.log('WebSocket connected');
        };
        
                ws.onclose = (event) => {
            statusEl.textContent = 'Disconnected';
            statusEl.className = 'status disconnected';
                    console.log('WebSocket disconnected', event.code, event.reason);
                    
                    // Attempt to reconnect (unless it was a clean close or manual close)
                    if (event.code !== 1000) { // 1000 = normal closure
                        scheduleReconnect();
                    }
        };
        
        ws.onerror = (error) => {
            console.error('WebSocket error:', error);
                    statusEl.textContent = 'Error';
                    statusEl.className = 'status disconnected';
        };
        
        ws.onmessage = (event) => {
            const data = JSON.parse(event.data);
            console.log('Received:', data);
                    
                    // Handle BPM and signature updates
                    if (data.type === 'tempoAndSignature') {
                        updateAbletonInfo(data.tempo, data.signatureNumerator, data.signatureDenominator);
                        // Update sequencer when signature changes
                        if (data.signatureNumerator) {
                            updateBeatSequencer(data.signatureNumerator);
                        }
                    }
                    
                    // Handle beat updates
                    if (data.type === 'beat' && data.beatNumber !== undefined) {
                        updateBeatIndicator(data.beatNumber, data.bar);
                    }
                };
                
            } catch (error) {
                console.error('Failed to create WebSocket:', error);
                scheduleReconnect();
            }
        }
        
        function scheduleReconnect() {
            // Don't schedule if already scheduled
            if (reconnectTimeout) return;
            
            reconnectAttempts++;
            
            // Calculate delay with exponential backoff (capped at maxReconnectDelay)
            const delay = Math.min(reconnectDelay * Math.pow(1.5, reconnectAttempts - 1), maxReconnectDelay);
            
            statusEl.textContent = `Reconnecting... (attempt ${reconnectAttempts})`;
            console.log(`Scheduling reconnect in ${delay}ms (attempt ${reconnectAttempts})`);
            
            reconnectTimeout = setTimeout(() => {
                reconnectTimeout = null;
                connect();
            }, delay);
        }
        
        // Initial connection
        connect();
        
        // Handle keyboard shortcuts
        commandArea.addEventListener('keydown', (e) => {
            const isCtrl = e.ctrlKey || e.metaKey;
            const isShift = e.shiftKey;
            const isAlt = e.altKey;
            
            // Ctrl + / = toggle comment on selected lines
            if (isCtrl && !isAlt && !isShift && (e.key === '/' || e.key === '?')) {
                e.preventDefault();
                toggleComment();
            }
            // Ctrl + H = clear all cycles
            else if (isCtrl && !isAlt && !isShift && e.key === 'h') {
                e.preventDefault();
                clearAllCycles();
            }
            // Ctrl + S = save whole track (queue playCycle for current track)
            else if (isCtrl && !isAlt && !isShift && e.key === 's') {
                e.preventDefault();
                queuePlayCycleForCurrentTrack();
            }
            // Ctrl + Enter = queue playTrack for current track (SWAPPED)
            else if (isCtrl && !isAlt && !isShift && e.key === 'Enter') {
                e.preventDefault();
                queuePlayTrackForCurrentTrack();
            }
            // Ctrl + Shift + Enter = queue playTrack for selected lines (SWAPPED)
            else if (isCtrl && !isAlt && isShift && e.key === 'Enter') {
                e.preventDefault();
                queuePlayTrackForSelection();
            }
            // Ctrl + Alt + S = playCycle for selected lines
            else if (isCtrl && isAlt && !isShift && e.key === 's') {
                e.preventDefault();
                playCycleForSelection();
            }
            // Ctrl + Alt + Shift + S = playCycle for current track
            else if (isCtrl && isAlt && isShift && e.key === 'S') {
                e.preventDefault();
                playCycleForCurrentTrack();
            }
            // Ctrl + Alt + Enter = playTrack for current track (SWAPPED)
            else if (isCtrl && isAlt && !isShift && e.key === 'Enter') {
                e.preventDefault();
                playTrackForCurrentTrack();
            }
            // Ctrl + Alt + Shift + Enter = playTrack for selected lines (SWAPPED)
            else if (isCtrl && isAlt && isShift && e.key === 'Enter') {
                e.preventDefault();
                playTrackForSelection();
            }
        });
        
        // Get selected text from textarea
        function getSelectedText() {
            const start = commandArea.selectionStart;
            const end = commandArea.selectionEnd;
            if (start === end) return null; // No selection
            return commandArea.value.substring(start, end);
        }
        
        // Toggle comment on selected lines
        function toggleComment() {
            const fullText = commandArea.value;
            const start = commandArea.selectionStart;
            const end = commandArea.selectionEnd;
            
            // Find the lines that contain the selection
            let lineStart = start;
            let lineEnd = end;
            
            // Find start of first line containing selection
            while (lineStart > 0 && fullText[lineStart - 1] !== '\n') {
                lineStart--;
            }
            
            // Find end of last line containing selection
            while (lineEnd < fullText.length && fullText[lineEnd] !== '\n') {
                lineEnd++;
            }
            
            // Get all lines in the selection
            const selectedText = fullText.substring(lineStart, lineEnd);
            const lines = selectedText.split('\n');
            
            // Determine if all selected lines are commented (to decide toggle direction)
            let allCommented = true;
            let someCommented = false;
            for (const line of lines) {
                const trimmed = line.trim();
                if (trimmed && !trimmed.startsWith('//')) {
                    allCommented = false;
                } else if (trimmed && trimmed.startsWith('//')) {
                    someCommented = true;
                }
            }
            
            // Process each line
            const processedLines = lines.map(line => {
                const trimmed = line.trim();
                
                // Empty line - return as-is
                if (!trimmed) return line;
                
                // If line starts with //, remove comment
                if (trimmed.startsWith('//')) {
                    // Remove // and any space after it, but preserve indentation
                    const commentIndex = line.indexOf('//');
                    const afterComment = line.substring(commentIndex + 2).trimStart();
                    const beforeComment = line.substring(0, commentIndex);
                    return beforeComment + afterComment;
                } else {
                    // Add // at the start (preserve indentation)
                    const leadingWhitespace = line.match(/^\s*/)[0];
                    const restOfLine = line.substring(leadingWhitespace.length);
                    return leadingWhitespace + '//' + restOfLine;
                }
            });
            
            // Replace the selected lines
            const newText = fullText.substring(0, lineStart) + 
                          processedLines.join('\n') + 
                          fullText.substring(lineEnd);
            
            // Update textarea
            commandArea.value = newText;
            
            // Restore selection (adjust for length changes)
            const lengthDiff = newText.length - fullText.length;
            commandArea.selectionStart = lineStart;
            commandArea.selectionEnd = lineEnd + lengthDiff;
        }
        
        // Get selected lines or line containing cursor
        function getSelectedLines() {
            const fullText = commandArea.value;
            const start = commandArea.selectionStart;
            const end = commandArea.selectionEnd;
            
            // Check if there's actual text selection (not just cursor position)
            const hasSelection = start !== end;
            
            if (hasSelection) {
                // Use actual selection boundaries
                let lineStart = start;
                let lineEnd = end;
                
                // Find start of first line containing selection
                while (lineStart > 0 && fullText[lineStart - 1] !== '\n') {
                    lineStart--;
                }
                
                // Find end of last line containing selection
                while (lineEnd < fullText.length && fullText[lineEnd] !== '\n') {
                    lineEnd++;
                }
                
                const selectedText = fullText.substring(lineStart, lineEnd);
                // Get all lines within selection, filtering empty and comments
                const lines = selectedText.split('\n').filter(line => {
                    const trimmed = line.trim();
                    return trimmed && !trimmed.startsWith('//');
                });
                
                if (lines.length === 0) return null;
                // Join all selected lines
                return lines.join(' ');
            } else {
                // No selection - use line containing cursor
                const cursorPos = start;
                let lineStart = cursorPos;
                let lineEnd = cursorPos;
                
                // Find start of line containing cursor
                while (lineStart > 0 && fullText[lineStart - 1] !== '\n') {
                    lineStart--;
                }
                
                // Find end of line containing cursor
                while (lineEnd < fullText.length && fullText[lineEnd] !== '\n') {
                    lineEnd++;
                }
                
                const lineText = fullText.substring(lineStart, lineEnd).trim();
                if (!lineText || lineText.startsWith('//')) return null;
                
                return lineText;
            }
        }
        
        // Remove comments (lines starting with //) from text
        function removeComments(text) {
            if (!text) return text;
            const lines = text.split('\n');
            const filteredLines = lines.map(line => {
                // Find // on the line and remove everything from // to end of line
                const commentIndex = line.indexOf('//');
                if (commentIndex !== -1) {
                    // Check if // is not inside quotes or within another token
                    // Simple check: if // appears, remove from that position to end of line
                    return line.substring(0, commentIndex);
                }
                return line;
            });
            return filteredLines.join('\n');
        }
        
        // Check if text matches t(...).stop() or t(...).play(...).stop() syntax
        function isStopSyntax(text) {
            if (!text) return false;
            const trimmed = text.trim().replace(/\s+/g, '');
            // Match: t(...).stop() or t(...).stop or t(...).play(...).stop() or t(...).play(...).stop
            const stopMatch = trimmed.match(/^t\([^)]+\)(?:\.(?:bpm|sn|sd)\([^)]+\))*(?:\.play\([^)]*\))?\.stop\(?\)?$/);
            return stopMatch !== null;
        }
        
        // Find the t(...).play(...) or t(...).play(...).stop() wrapper that contains the cursor/selection
        function findCurrentTrack() {
            const fullText = commandArea.value;
            const cursorPos = commandArea.selectionStart;
            
            // Find the nearest t(...) before cursor
            let searchStart = 0;
            let bestMatch = null;
            let bestEnd = -1;
            
            while (true) {
                const tIndex = fullText.indexOf('t(', searchStart);
                if (tIndex === -1 || tIndex > cursorPos) break;
                
                // Find matching closing parenthesis for .play(...) and optionally .stop()
                let depth = 0;
                let pos = tIndex;
                let inPlay = false;
                let playStartPos = -1;
                let playEndPos = -1;
                
                while (pos < fullText.length) {
                    if (fullText.substring(pos).startsWith('.play(')) {
                        inPlay = true;
                        playStartPos = pos + 6; // Position after '.play('
                        pos += 6; // Skip '.play('
                        depth = 1;
                        continue;
                    }
                    
                    if (fullText[pos] === '(') depth++;
                    else if (fullText[pos] === ')') {
                        depth--;
                        if (inPlay && depth === 0) {
                            // Found complete t(...).play(...)
                            playEndPos = pos + 1;
                            
                            // Check for .stop() after .play(...)
                            let afterPlayPos = playEndPos;
                            // Skip whitespace
                            while (afterPlayPos < fullText.length && /\s/.test(fullText[afterPlayPos])) {
                                afterPlayPos++;
                            }
                            
                            // Check if .stop() or .stop follows
                            if (fullText.substring(afterPlayPos).startsWith('.stop()')) {
                                const stopEnd = afterPlayPos + 7;
                                // Check if cursor is within this track including stop
                                if (cursorPos >= tIndex && cursorPos <= stopEnd) {
                                    bestMatch = fullText.substring(tIndex, stopEnd);
                                    bestEnd = stopEnd;
                                    break;
                                }
                            } else if (fullText.substring(afterPlayPos).startsWith('.stop')) {
                                const stopEnd = afterPlayPos + 6;
                                // Check if cursor is within this track including stop
                                if (cursorPos >= tIndex && cursorPos <= stopEnd) {
                                    bestMatch = fullText.substring(tIndex, stopEnd);
                                    bestEnd = stopEnd;
                                    break;
                                }
                            }
                            
                            // Check if cursor is within this track (without stop)
                            if (cursorPos >= tIndex && cursorPos <= playEndPos) {
                                bestMatch = fullText.substring(tIndex, playEndPos);
                                bestEnd = playEndPos;
                                break;
                            }
                            break;
                        }
                    }
                    pos++;
                }
                
                searchStart = tIndex + 2;
            }
            
            // Also check for standalone t(...).stop() (without .play())
            if (!bestMatch || cursorPos > bestEnd) {
                searchStart = 0;
                while (true) {
                    const tIndex = fullText.indexOf('t(', searchStart);
                    if (tIndex === -1 || tIndex > cursorPos) break;
                    
                    // Find the end of t(...)
                    let pos = tIndex + 2;
                    let depth = 1;
                    while (pos < fullText.length && depth > 0) {
                        if (fullText[pos] === '(') depth++;
                        else if (fullText[pos] === ')') depth--;
                        pos++;
                    }
                    
                    if (depth === 0) {
                        // Check for .stop() after t(...)
                        let afterT = pos;
                        // Skip whitespace
                        while (afterT < fullText.length && /\s/.test(fullText[afterT])) {
                            afterT++;
                        }
                        
                        // Check if .stop() or .stop follows
                        if (fullText.substring(afterT).startsWith('.stop()')) {
                            const stopEnd = afterT + 7;
                            if (cursorPos >= tIndex && cursorPos <= stopEnd) {
                                bestMatch = fullText.substring(tIndex, stopEnd);
                                bestEnd = stopEnd;
                                break;
                            }
                        } else if (fullText.substring(afterT).startsWith('.stop')) {
                            const stopEnd = afterT + 6;
                            if (cursorPos >= tIndex && cursorPos <= stopEnd) {
                                bestMatch = fullText.substring(tIndex, stopEnd);
                                bestEnd = stopEnd;
                                break;
                            }
                        }
                    }
                    
                    searchStart = tIndex + 2;
                }
            }
            
            // Remove comments from the found track
            if (bestMatch) {
                bestMatch = removeComments(bestMatch);
            }
            
            return bestMatch;
        }
        
        // Apply t() wrapper settings to a sequence string
        function applyWrapperSettings(sequenceStr, wrapperStr) {
            if (!wrapperStr || !wrapperStr.startsWith('t(')) {
                return sequenceStr; // No wrapper, return as-is
            }
            
            const parsed = parseMethodChain(wrapperStr);
            if (!parsed) return sequenceStr;
            
            // Extract cycleId and build new t() wrapper with sequence
            const match = wrapperStr.match(/^t\(([^)]+)\)/);
            if (!match) return sequenceStr;
            
            const cycleId = match[1];
            let result = `t(${cycleId})`;
            
            if (parsed.tempo !== null) result += `.bpm(${parsed.tempo})`;
            if (parsed.sn !== null) result += `.sn(${parsed.sn})`;
            if (parsed.sd !== null) result += `.sd(${parsed.sd})`;
            
            result += `.play(${sequenceStr})`;
            return result;
        }
        
        // Queue playCycle for selected lines
        function queuePlayCycleForSelection() {
            const selectedSeq = getSelectedLines();
            if (!selectedSeq) {
                console.warn('No valid sequence selected');
                return;
            }
            
            // Check if selected text is a stop command
            if (isStopSyntax(selectedSeq)) {
                sendToServer({
                    action: 'playTrack', // Use any action, server will detect stop syntax
                    cycleStr: selectedSeq
                });
                return;
            }
            
            const wrapper = findCurrentTrack();
            const fullCommand = applyWrapperSettings(selectedSeq, wrapper);
            const cleanCommand = removeComments(fullCommand);
            
            // Check again after applying wrapper settings
            if (isStopSyntax(cleanCommand)) {
                sendToServer({
                    action: 'playTrack', // Use any action, server will detect stop syntax
                    cycleStr: cleanCommand
                });
                return;
            }
            
            const parsed = parseMethodChain(cleanCommand);
            
            sendToServer({
                action: 'addCycleToQueue',
                id: null,
                cycleStr: cleanCommand,
                tempo: parsed?.tempo || null,
                signatureNumerator: parsed?.sn || null,
                signatureDenominator: parsed?.sd || null
            });
        }
        
        // Queue playCycle for current track
        function queuePlayCycleForCurrentTrack() {
            const track = findCurrentTrack();
            if (!track) {
                console.warn('No t() track found');
                return;
            }
            
            // Check if it's a stop command
            if (isStopSyntax(track)) {
                sendToServer({
                    action: 'playTrack', // Use any action, server will detect stop syntax
                    cycleStr: track
                });
                return;
            }
            
            const cleanTrack = removeComments(track);
            const parsed = parseMethodChain(cleanTrack);
            sendToServer({
                action: 'addCycleToQueue',
                id: null,
                cycleStr: cleanTrack,
                tempo: parsed?.tempo || null,
                signatureNumerator: parsed?.sn || null,
                signatureDenominator: parsed?.sd || null
            });
        }
        
        // Queue playTrack for selected lines
        function queuePlayTrackForSelection() {
            const selectedSeq = getSelectedLines();
            if (!selectedSeq) {
                console.warn('No valid sequence selected');
                return;
            }
            
            // Check if selected text is a stop command
            if (isStopSyntax(selectedSeq)) {
                sendToServer({
                    action: 'playTrack', // Use any action, server will detect stop syntax
                    cycleStr: selectedSeq
                });
                return;
            }
            
            const wrapper = findCurrentTrack();
            const fullCommand = applyWrapperSettings(selectedSeq, wrapper);
            const cleanCommand = removeComments(fullCommand);
            
            // Check again after applying wrapper settings
            if (isStopSyntax(cleanCommand)) {
                sendToServer({
                    action: 'playTrack', // Use any action, server will detect stop syntax
                    cycleStr: cleanCommand
                });
                return;
            }
            
            const parsed = parseMethodChain(cleanCommand);
            
            sendToServer({
                action: 'addTrackToQueue',
                id: null,
                cycleStr: cleanCommand,
                tempo: parsed?.tempo || null,
                signatureNumerator: parsed?.sn || null,
                signatureDenominator: parsed?.sd || null
            });
        }
        
        // Queue playTrack for current track
        function queuePlayTrackForCurrentTrack() {
            const track = findCurrentTrack();
            if (!track) {
                console.warn('No t() track found');
                return;
            }
            
            // Check if it's a stop command
            if (isStopSyntax(track)) {
                sendToServer({
                    action: 'playTrack', // Use any action, server will detect stop syntax
                    cycleStr: track
                });
                return;
            }
            
            const cleanTrack = removeComments(track);
            const parsed = parseMethodChain(cleanTrack);
            sendToServer({
                action: 'addTrackToQueue',
                id: null,
                cycleStr: cleanTrack,
                tempo: parsed?.tempo || null,
                signatureNumerator: parsed?.sn || null,
                signatureDenominator: parsed?.sd || null
            });
        }
        
        // Play playCycle for selected lines (immediate)
        function playCycleForSelection() {
            const selectedSeq = getSelectedLines();
            if (!selectedSeq) {
                console.warn('No valid sequence selected');
                return;
            }
            
            // Check if selected text is a stop command
            if (isStopSyntax(selectedSeq)) {
                sendToServer({
                    action: 'playTrack', // Use any action, server will detect stop syntax
                    cycleStr: selectedSeq
                });
                return;
            }
            
            const wrapper = findCurrentTrack();
            const fullCommand = applyWrapperSettings(selectedSeq, wrapper);
            const cleanCommand = removeComments(fullCommand);
            
            // Check again after applying wrapper settings
            if (isStopSyntax(cleanCommand)) {
                sendToServer({
                    action: 'playTrack', // Use any action, server will detect stop syntax
                    cycleStr: cleanCommand
                });
                return;
            }
            
            const parsed = parseMethodChain(cleanCommand);
            
            sendToServer({
                action: 'playCycle',
                id: null,
                cycleStr: cleanCommand,
                tempo: parsed?.tempo || null,
                signatureNumerator: parsed?.sn || null,
                signatureDenominator: parsed?.sd || null
            });
        }
        
        // Play playCycle for current track (immediate)
        function playCycleForCurrentTrack() {
            const track = findCurrentTrack();
            if (!track) {
                console.warn('No t() track found');
                return;
            }
            
            // Check if it's a stop command
            if (isStopSyntax(track)) {
                sendToServer({
                    action: 'playTrack', // Use any action, server will detect stop syntax
                    cycleStr: track
                });
                return;
            }
            
            const cleanTrack = removeComments(track);
            const parsed = parseMethodChain(cleanTrack);
            sendToServer({
                action: 'playCycle',
                id: null,
                cycleStr: cleanTrack,
                tempo: parsed?.tempo || null,
                signatureNumerator: parsed?.sn || null,
                signatureDenominator: parsed?.sd || null
            });
        }
        
        // Play playTrack for selected lines (immediate)
        function playTrackForSelection() {
            const selectedSeq = getSelectedLines();
            if (!selectedSeq) {
                console.warn('No valid sequence selected');
                return;
            }
            
            // Check if selected text is a stop command
            if (isStopSyntax(selectedSeq)) {
                sendToServer({
                    action: 'playTrack', // Use any action, server will detect stop syntax
                    cycleStr: selectedSeq
                });
                return;
            }
            
            const wrapper = findCurrentTrack();
            const fullCommand = applyWrapperSettings(selectedSeq, wrapper);
            const cleanCommand = removeComments(fullCommand);
            
            // Check again after applying wrapper settings
            if (isStopSyntax(cleanCommand)) {
                sendToServer({
                    action: 'playTrack', // Use any action, server will detect stop syntax
                    cycleStr: cleanCommand
                });
                return;
            }
            
            const parsed = parseMethodChain(cleanCommand);
            
            sendToServer({
                action: 'playTrack',
                id: null,
                cycleStr: cleanCommand,
                tempo: parsed?.tempo || null,
                signatureNumerator: parsed?.sn || null,
                signatureDenominator: parsed?.sd || null
            });
        }
        
        // Play playTrack for current track (immediate)
        function playTrackForCurrentTrack() {
            const track = findCurrentTrack();
            if (!track) {
                console.warn('No t() track found');
                return;
            }
            
            // Check if it's a stop command
            if (isStopSyntax(track)) {
                sendToServer({
                    action: 'playTrack', // Use any action, server will detect stop syntax
                    cycleStr: track
                });
                return;
            }
            
            const cleanTrack = removeComments(track);
            const parsed = parseMethodChain(cleanTrack);
            sendToServer({
                action: 'playTrack',
                id: null,
                cycleStr: cleanTrack,
                tempo: parsed?.tempo || null,
                signatureNumerator: parsed?.sn || null,
                signatureDenominator: parsed?.sd || null
            });
        }
        
        // Join multi-line commands by tracking parentheses depth
        function joinMultiLineCommand(text) {
            const lines = text.split('\n');
            const commands = [];
            let currentCommand = '';
            let parenDepth = 0;
            let inString = false;
            let stringChar = null;
            
            for (const line of lines) {
                const trimmed = line.trim();
                
                // Skip empty lines and comments (but only when not in the middle of a command)
                if (!trimmed || trimmed.startsWith('//')) {
                    if (currentCommand && parenDepth === 0) {
                        commands.push(currentCommand.trim());
                        currentCommand = '';
                    }
                    continue;
                }
                
                // Track parentheses and strings across the entire line
                for (let i = 0; i < line.length; i++) {
                    const char = line[i];
                    const prevChar = i > 0 ? line[i-1] : null;
                    
                    if (!inString && (char === '"' || char === "'")) {
                        inString = true;
                        stringChar = char;
                    } else if (inString && char === stringChar && prevChar !== '\\') {
                        inString = false;
                        stringChar = null;
                    } else if (!inString) {
                        if (char === '(') parenDepth++;
                        else if (char === ')') parenDepth--;
                    }
                }
                
                // Add line to current command
                if (currentCommand) {
                    currentCommand += ' ' + trimmed;
                } else {
                    currentCommand = trimmed;
                }
                
                // If we've closed all parentheses and not in a string, command is complete
                if (parenDepth === 0 && !inString && currentCommand) {
                    commands.push(currentCommand.trim());
                    currentCommand = '';
                    parenDepth = 0;
                }
            }
            
            // Add any remaining command
            if (currentCommand.trim()) {
                commands.push(currentCommand.trim());
            }
            
            return commands.filter(cmd => cmd.length > 0);
        }
        
        // Split text into individual commands (now simplified since joinMultiLineCommand handles it)
        function splitCommands(text) {
            // The joinMultiLineCommand already returns an array of commands
            // But if text wasn't processed, split by newlines and filter
            const commands = Array.isArray(text) ? text : [text];
            return commands.filter(cmd => cmd.trim() && !cmd.trim().startsWith('//'));
        }
        
        // Helper function to evaluate chained multiplication/division expressions
        // Supports: baseValue*2/3*4, where baseValue can be tmp, sn, sd, or a number
        function evaluateExpression(expr, context = {}) {
            if (!expr || typeof expr !== 'string') return null;
            
            const norm = expr.trim().toLowerCase();
            
            // Parse base value: tmp, sn, sd, or a number
            let baseValue = null;
            let remainingExpr = '';
            
            if (norm === 'tmp' && context.tmp !== undefined && context.tmp !== null) {
                baseValue = context.tmp;
            } else if (norm === 'sn' && context.sn !== undefined && context.sn !== null) {
                baseValue = context.sn;
            } else if (norm === 'sd' && context.sd !== undefined && context.sd !== null) {
                baseValue = context.sd;
            } else if (norm.startsWith('tmp')) {
                if (context.tmp !== undefined && context.tmp !== null) {
                    baseValue = context.tmp;
                    remainingExpr = norm.substring(3); // Remove 'tmp' prefix
                }
            } else if (norm.startsWith('sn')) {
                if (context.sn !== undefined && context.sn !== null) {
                    baseValue = context.sn;
                    remainingExpr = norm.substring(2); // Remove 'sn' prefix
                }
            } else if (norm.startsWith('sd')) {
                if (context.sd !== undefined && context.sd !== null) {
                    baseValue = context.sd;
                    remainingExpr = norm.substring(2); // Remove 'sd' prefix
                }
            } else {
                // Try to parse as a number
                const numMatch = norm.match(/^(\d+(?:\.\d+)?)/);
                if (numMatch) {
                    baseValue = parseFloat(numMatch[1]);
                    remainingExpr = norm.substring(numMatch[1].length);
                }
            }
            
            if (baseValue === null || isNaN(baseValue)) return null;
            
            // If no remaining expression, return base value
            if (!remainingExpr) return baseValue;
            
            // Parse and apply operations from left to right
            // Pattern: *N or /N, where N can be any number
            const operationRegex = /([*\/])(\d+(?:\.\d+)?)/g;
            let result = baseValue;
            let match;
            let lastIndex = 0;
            
            while ((match = operationRegex.exec(remainingExpr)) !== null) {
                // Check that we're starting where we left off (no gaps)
                if (match.index !== lastIndex) {
                    return null; // Invalid - there's text between operations
                }
                
                const op = match[1];
                const num = parseFloat(match[2]);
                
                if (isNaN(num) || num <= 0) return null; // Invalid operation
                
                if (op === '*') {
                    result = result * num;
                } else if (op === '/') {
                    result = result / num;
                }
                
                lastIndex = match.index + match[0].length;
            }
            
            // Check if we consumed the entire expression
            if (lastIndex !== remainingExpr.length) {
                // There's extra text that wasn't consumed - invalid expression
                return null;
            }
            
            return result;
        }
        
        // Simple parser for new syntax (client-side helper)
        function parseMethodChain(str) {
            if (!str || !str.trim().startsWith('t(')) return null;
            
            const match = str.match(/^t\(([^)]+)\)/);
            if (!match) return null;
            
            const cycleId = match[1].trim();
            let bpm = null, sn = null, sd = null;
            
            // Parse .bpm(...)
            const bpmMatch = str.match(/\.bpm\(([^)]+)\)/);
            if (bpmMatch) {
                const bpmStr = bpmMatch[1].trim();
                // Support tmp*2/3*4 syntax where tmp is Ableton tempo, or regular number*2/3*4
                const exprResult = evaluateExpression(bpmStr.toLowerCase(), { tmp: currentAbletonTempo });
                if (exprResult !== null && !isNaN(exprResult) && exprResult > 0) {
                    bpm = exprResult;
                }
            }
            
            // Parse .sn(...)
            const snMatch = str.match(/\.sn\(([^)]+)\)/);
            if (snMatch) {
                const snStr = snMatch[1].trim();
                // Support sn*2/3*4 syntax where sn is Ableton signature numerator, or regular number*2/3*4
                const exprResult = evaluateExpression(snStr.toLowerCase(), { sn: currentAbletonSignatureNumerator });
                if (exprResult !== null && !isNaN(exprResult) && exprResult > 0) {
                    sn = Math.round(exprResult);
                }
            }
            
            // Parse .sd(...)
            const sdMatch = str.match(/\.sd\(([^)]+)\)/);
            if (sdMatch) {
                const sdStr = sdMatch[1].trim();
                // Support sd*2/3*4 syntax where sd is Ableton signature denominator, or regular number*2/3*4
                const exprResult = evaluateExpression(sdStr.toLowerCase(), { sd: currentAbletonSignatureDenominator });
                if (exprResult !== null && !isNaN(exprResult) && exprResult > 0) {
                    sd = Math.round(exprResult);
                }
            }
            
            return { cycleId, tempo: bpm, sn, sd };
        }
        
        // Update Ableton info display
        let currentBeatNumber = 0;
        let currentBarNumber = 0;
        let currentAbletonTempo = null; // Store current Ableton tempo for tmp*f syntax
        let currentAbletonSignatureNumerator = null; // Store for sn*f syntax
        let currentAbletonSignatureDenominator = null; // Store for sd*f syntax
        
        function updateAbletonInfo(bpm, numerator, denominator) {
            // Store tempo for tmp*f syntax support
            if (bpm !== null && bpm !== undefined) {
                currentAbletonTempo = bpm;
            }
            // Store signature for sn*f and sd*f syntax support
            if (numerator !== null && numerator !== undefined) {
                currentAbletonSignatureNumerator = numerator;
            }
            if (denominator !== null && denominator !== undefined) {
                currentAbletonSignatureDenominator = denominator;
            }
            const bpmDisplay = document.getElementById('bpmDisplay');
            const signatureDisplay = document.getElementById('signatureDisplay');
            
            if (bpm !== null && bpm !== undefined) {
                bpmDisplay.textContent = `BPM: ${Math.round(bpm)}`;
            } else {
                bpmDisplay.textContent = 'BPM: --';
            }
            
            if (numerator !== null && numerator !== undefined && denominator !== null && denominator !== undefined) {
                signatureDisplay.textContent = `Signature: ${numerator}/${denominator}`;
                updateBeatSequencer(numerator);
            } else {
                signatureDisplay.textContent = 'Signature: --/--';
            }
        }
        
        // Create/update beat sequencer circles
        function updateBeatSequencer(beatsPerBar) {
            const sequencer = document.getElementById('beatSequencer');
            sequencer.innerHTML = '';
            
            for (let i = 1; i <= beatsPerBar; i++) {
                const circle = document.createElement('div');
                circle.className = 'beatCircle';
                circle.id = `beat-${i}`;
                sequencer.appendChild(circle);
            }
            
            // Update active beat if we have current beat info
            if (currentBeatNumber > 0) {
                updateBeatIndicator(currentBeatNumber, currentBarNumber);
            }
        }
        
        // Update which beat circle is active
        function updateBeatIndicator(beatNumber, barNumber) {
            currentBeatNumber = beatNumber;
            currentBarNumber = barNumber || 0;
            
            // Remove active class from all circles
            document.querySelectorAll('.beatCircle').forEach(circle => {
                circle.classList.remove('active');
            });
            
            // Add active class to current beat
            const activeCircle = document.getElementById(`beat-${beatNumber}`);
            if (activeCircle) {
                activeCircle.classList.add('active');
            }
        }
        
        // Helper function to send messages with connection check
        function sendToServer(data) {
            if (ws && ws.readyState === WebSocket.OPEN) {
                ws.send(JSON.stringify(data));
            } else {
                console.warn('WebSocket not connected, message queued:', data);
                // Optionally queue messages for when connection is restored
                // For now, just log a warning
                statusEl.textContent = 'Not Connected - Retrying...';
                statusEl.className = 'status disconnected';
            }
        }
        
        function clearAllCycles() {
            sendToServer({
                action: 'clearAllCycles'
            });
            console.log('Clear all cycles requested');
        }
        
        // Syntax highlighting for brackets/parentheses
        let highlightOverlay = null;
        
        // Initialize overlay after DOM is ready
        function initHighlighting() {
            highlightOverlay = document.getElementById('highlightOverlay');
            if (highlightOverlay && commandArea) {
                highlightBrackets();
            }
        }
        
        function highlightBrackets() {
            if (!highlightOverlay) {
                // Try to get overlay if not set
                highlightOverlay = document.getElementById('highlightOverlay');
                if (!highlightOverlay) return;
            }
            
            const text = commandArea.value || '';
            
            // Process entire text for multiline bracket matching
            const highlighted = highlightText(text);
            
            // Clear overlay and add highlighted content
            highlightOverlay.innerHTML = '';
            if (highlighted) {
                highlightOverlay.appendChild(highlighted);
            }
        }
        
        function highlightText(text) {
            if (!text) {
                return document.createDocumentFragment();
            }
            
            // First, process the entire text as a whole for bracket context
            // Then highlight character by character while maintaining line structure
            return highlightTextWithContext(text);
        }
        
        function highlightTextWithContext(text) {
            const result = document.createDocumentFragment();
            const bracketChars = { '(': ')', '[': ']', '{': '}', '<': '>' };
            const closingBrackets = { ')': '(', ']': '[', '}': '{', '>': '<' };
            
            // Process entire text for bracket matching across lines
            const lines = text.split('\n');
            const fullText = text;
            
            // Track bracket state across all lines
            const brackets = []; // Track current bracket stack: { char, index, isSeqBracket, level }
            let trackLevel = 0; // Track level for track brackets (t(), .play(), etc.)
            let seqLevel = 0; // Sequence level for sequence brackets ([...], .c(), etc.)
            let insideSeqBlock = false; // Track if we're currently inside a [ ... ] block
            
            // First pass: validate brackets across entire text
            const errors = new Set();
            const stack = [];
            let charIndex = 0;
            
            for (let lineIndex = 0; lineIndex < lines.length; lineIndex++) {
                const line = lines[lineIndex];
                for (let i = 0; i < line.length; i++) {
                    const char = line[i];
                    const nextChar = i < line.length - 1 ? line[i + 1] : '';
                    
                    // Skip comments
                    if (char === '/' && nextChar === '/') {
                        break;
                    }
                    
                    if (bracketChars[char]) {
                        stack.push({ char, index: charIndex });
                    } else if (closingBrackets[char]) {
                        if (stack.length === 0 || closingBrackets[char] !== stack[stack.length - 1].char) {
                            errors.add(charIndex);
                        } else {
                            stack.pop();
                        }
                    }
                    charIndex++;
                }
                charIndex++; // For newline
            }
            
            // Mark unmatched opening brackets
            stack.forEach(item => errors.add(item.index));
            
            // Helper to determine bracket type - now uses full text context
            function determineBracketType(char, globalIndex) {
                // [ and ] are ALWAYS sequence level
                if (char === '[' || char === ']') {
                    return { isSeq: true, reason: 'sequence-block' };
                }
                
                if (char === '(' || char === ')') {
                    const lookback = fullText.substring(0, globalIndex);
                    
                    // Sequence modifiers
                    const seqModifiers = ['.c', '.ds', '.co', '.nRange', '.vRange', '.dRange', '.nArp', '.vArp', '.dArp', '.pm', '.pr', '.v', '.d', '.p', '.n', '.a'];
                    // Track modifiers
                    const trackModifiers = ['.play', '.bpm', '.sn', '.sd', '.stop'];
                    
                    // Check what comes immediately before this bracket
                    const modifierMatch = lookback.match(/([a-zA-Z0-9_]+|\.\w+)\s*$/);
                    if (modifierMatch) {
                        const modifier = modifierMatch[1];
                        
                        // Check for function calls like n(, a(
                        if (modifier.match(/^(n|a)$/)) {
                            // n( or a( - check if inside sequence block
                            let inSeq = false;
                            let depth = 0;
                            for (let k = lookback.length - 1; k >= 0; k--) {
                                if (lookback[k] === ']') depth++;
                                else if (lookback[k] === '[') {
                                    depth--;
                                    if (depth === 0) {
                                        inSeq = true;
                                        break;
                                    }
                                }
                            }
                            return { isSeq: inSeq, reason: inSeq ? 'sequence-function' : 'track-function' };
                        }
                        
                        // Check for dot modifiers
                        if (modifier.startsWith('.')) {
                            if (seqModifiers.some(m => modifier === m)) {
                                return { isSeq: true, reason: 'sequence-modifier' };
                            } else if (trackModifiers.some(m => modifier === m)) {
                                return { isSeq: false, reason: 'track-modifier' };
                            }
                        }
                    }
                    
                    // Check if we're inside a sequence block [ ... ]
                    let bracketDepth = 0;
                    let foundSeqBlock = false;
                    for (let k = lookback.length - 1; k >= 0; k--) {
                        if (lookback[k] === ']') bracketDepth++;
                        else if (lookback[k] === '[') {
                            bracketDepth--;
                            if (bracketDepth === 0) {
                                foundSeqBlock = true;
                                break;
                            }
                        }
                    }
                    
                    // Check for track-level function calls first
                    if (lookback.trim().match(/(t|\.play|\.bpm|\.sn|\.sd|\.stop)\s*\(\s*$/)) {
                        return { isSeq: false, reason: 'track-declaration-or-modifier' };
                    }
                    
                    if (foundSeqBlock) {
                        return { isSeq: true, reason: 'inside-sequence-block' };
                    }
                    
                    // Default to track level
                    return { isSeq: false, reason: 'default-track' };
                }
                
                return { isSeq: false, reason: 'unknown' };
            }
            
            // Second pass: highlight character by character
            charIndex = 0;
            for (let lineIndex = 0; lineIndex < lines.length; lineIndex++) {
                const line = lines[lineIndex];
                
                for (let i = 0; i < line.length; i++) {
                    const char = line[i];
                    const nextChar = i < line.length - 1 ? line[i + 1] : '';
                    
                    // Check for comment start
                    if (char === '/' && nextChar === '/') {
                        // Add rest of line as plain text
                        for (let j = i; j < line.length; j++) {
                            const span = document.createElement('span');
                            span.className = 'char';
                            span.textContent = line[j];
                            result.appendChild(span);
                        }
                        charIndex += (line.length - i);
                        break;
                    }
                    
                    // Check if this character is an error
                    const isError = errors.has(charIndex);
                    
                     // Check if it's an opening bracket
                     if (bracketChars[char]) {
                         const bracketInfo = determineBracketType(char, charIndex);
                         const isSeqBracket = bracketInfo.isSeq;
                         
                         // Check if this is part of a chain inside a sequence block
                         // All chained items (.nRange(), .nArp(), .n(), .a(), etc.) should share level 1 with n()/a()
                         let isModifier = false;
                         let modifierParentLevel = null;
                         if (char === '(' && isSeqBracket && insideSeqBlock) {
                             // Look back to see if this is a modifier or chained function
                             // Get text before this position, remove all whitespace for matching
                             const lookbackRaw = fullText.substring(0, charIndex);
                             const lookbackNoWS = lookbackRaw.replace(/\s+/g, '');
                             
                             // Match modifiers like .nRange, .nArp, etc. at the end of the lookback
                             const modifierMatch = lookbackNoWS.match(/(\.(?:nRange|vRange|dRange|nArp|vArp|dArp|pm|pr|v|d|p))$/);
                             
                             // Also check if this is .n() or .a() that comes after a closing parenthesis
                             const chainFunctionMatch = lookbackNoWS.match(/(\.(?:n|a))$/);
                             
                             let isChainItem = false;
                             
                             if (modifierMatch) {
                                 // This is definitely a modifier
                                 isChainItem = true;
                             } else if (chainFunctionMatch) {
                                 // This might be a chained .n() or .a()
                                 // Check if it comes after a closing parenthesis (meaning it's chained)
                                 // Look backwards in the original text (with whitespace) to find the previous )
                                 let searchPos = charIndex - 1;
                                 let parenDepth = 0;
                                 let foundClosingParen = false;
                                 
                                 while (searchPos >= 0) {
                                     const charAtPos = fullText[searchPos];
                                     if (charAtPos === ')') {
                                         parenDepth++;
                                         foundClosingParen = true;
                                         break;
                                     } else if (charAtPos === '(') {
                                         if (parenDepth > 0) parenDepth--;
                                         else break; // Hit the opening of current function
                                     }
                                     searchPos--;
                                 }
                                 
                                 if (foundClosingParen) {
                                     // This .n() or .a() comes after a closing ), so it's chained
                                     isChainItem = true;
                                 }
                             }
                             
                             if (isChainItem) {
                                 // All chained items inside sequence blocks share level 1
                                 modifierParentLevel = 0;
                                 isModifier = true;
                             }
                         }
                         
                         let level;
                         // For [ brackets, ALWAYS sequence level 0
                         if (char === '[') {
                             level = 0;
                             insideSeqBlock = true;
                             seqLevel = 1;
                         } else if (isSeqBracket) {
                             if (isModifier && modifierParentLevel !== null) {
                                 // Use level 1 for all chained items (modifiers and chained functions)
                                 level = modifierParentLevel;
                                 // Don't increment seqLevel - chained items share the same level
                             } else if (insideSeqBlock) {
                                 // Check if this is the first n() or a() in the sequence block
                                 const lookbackRaw = fullText.substring(0, charIndex);
                                 const lookbackNoWS = lookbackRaw.replace(/\s+/g, '');
                                 
                                 // Check if this is directly after [ (first function in sequence)
                                 const firstFuncMatch = lookbackNoWS.match(/\[[^[]*(n|a)$/);
                                 
                                 // OR check if this is n() or a() that comes after something ending with )
                                 // (meaning it might be chained but not detected yet)
                                 const afterClosingParenMatch = lookbackNoWS.match(/\)(n|a)$/);
                                 
                                 if (firstFuncMatch || afterClosingParenMatch) {
                                     // First n() or a() in sequence block, or chained n()/a() gets level 1
                                     level = 1;
                                     seqLevel = 2; // Keep seqLevel at 2 for nested brackets
                                 } else {
                                     // Other brackets inside sequence block (nested content)
                                     level = seqLevel;
                                     seqLevel++;
                                 }
                             } else {
                                 level = 2;
                                 seqLevel = 0;
                                 insideSeqBlock = false;
                             }
                         } else {
                             level = trackLevel;
                             trackLevel++;
                             if (char === '(' && !isSeqBracket) {
                                 insideSeqBlock = false;
                             }
                         }
                         
                         brackets.push({ 
                             char, 
                             index: charIndex, 
                             isSeqBracket: isSeqBracket, 
                             level: level,
                             modifierParentLevel: isModifier ? modifierParentLevel : undefined
                         });
                        
                        const span = document.createElement('span');
                        span.className = isError ? 'bracket error' : 'bracket';
                        
                        if (isError) {
                            span.style.color = '#ff6b6b';
                        } else if (isSeqBracket) {
                            span.className += ` bracket-seq-${level % 4}`;
                        } else {
                            span.className += ` bracket-track-${level % 4}`;
                        }
                        
                        span.textContent = char;
                        result.appendChild(span);
                    }
                    // Check if it's a closing bracket
                    else if (closingBrackets[char]) {
                        let matched = false;
                        if (brackets.length > 0) {
                            const lastBracket = brackets[brackets.length - 1];
                            if (closingBrackets[char] === lastBracket.char) {
                                const wasSeqBracket = lastBracket.isSeqBracket;
                                const bracketLevel = lastBracket.level;
                                brackets.pop();
                                
                                // Update levels
                                if (wasSeqBracket) {
                                    if (char === ']') {
                                        seqLevel = 0;
                                        insideSeqBlock = false;
                                    } else {
                                        // Only decrement seqLevel if this wasn't a modifier
                                        // Modifiers don't increment seqLevel, so they shouldn't decrement it
                                        if (lastBracket.modifierParentLevel === undefined) {
                                            seqLevel = Math.max(0, seqLevel - 1);
                                        }
                                        // If it was a modifier, seqLevel stays the same
                                    }
                                } else {
                                    trackLevel = Math.max(0, trackLevel - 1);
                                }
                                
                                matched = true;
                                const span = document.createElement('span');
                                span.className = isError ? 'bracket error' : 'bracket';
                                
                                if (isError) {
                                    span.style.color = '#ff6b6b';
                                } else if (wasSeqBracket) {
                                    span.className += ` bracket-seq-${bracketLevel % 4}`;
                                } else {
                                    span.className += ` bracket-track-${bracketLevel % 4}`;
                                }
                                
                                span.textContent = char;
                                result.appendChild(span);
                            }
                        }
                        if (!matched) {
                            const span = document.createElement('span');
                            span.className = 'bracket error';
                            span.textContent = char;
                            result.appendChild(span);
                        }
                    }
                    // Regular character
                    else {
                        const span = document.createElement('span');
                        span.className = isError ? 'char error' : 'char';
                        span.textContent = char;
                        result.appendChild(span);
                    }
                    
                    charIndex++;
                }
                
                // Add newline (except after last line)
                if (lineIndex < lines.length - 1) {
                    const newlineSpan = document.createElement('span');
                    newlineSpan.className = 'char';
                    newlineSpan.textContent = '\n';
                    result.appendChild(newlineSpan);
                    charIndex++;
                }
            }
            
            return result;
        }
        
        // Legacy function for backward compatibility - now calls the new function
        function highlightLine(line) {
            if (!line) {
                return document.createDocumentFragment();
            }
            
            const result = document.createDocumentFragment();
            const bracketChars = { '(': ')', '[': ']', '{': '}', '<': '>' };
            const closingBrackets = { ')': '(', ']': '[', '}': '{', '>': '<' };
            const trackColors = [
                '#ff6b6b', /* Red */
                '#4a9eff', /* Blue */
                '#ffd93d', /* Yellow */
                '#6bcf7f'  /* Green */
            ];
            
            const seqColors = [
                '#ff8c42', /* Orange */
                '#9b59b6', /* Purple */
                '#00d9ff', /* Cyan */
                '#ff44aa'  /* Pink */
            ];
            
            const stack = []; // Track bracket pairs: { char, index, level }
            const errors = new Set(); // Track error positions
            
            // First pass: validate brackets from front to back
            for (let i = 0; i < line.length; i++) {
                const char = line[i];
                const nextChar = i < line.length - 1 ? line[i + 1] : '';
                
                // Skip comments - no bracket validation inside comments
                if (char === '/' && nextChar === '/') {
                    break; // Rest of line is comment, stop validation
                }
                
                if (bracketChars[char]) {
                    // Opening bracket
                    stack.push({ char, index: i, level: stack.length });
                } else if (closingBrackets[char]) {
                    // Closing bracket
                    if (stack.length === 0 || closingBrackets[char] !== stack[stack.length - 1].char) {
                        // Mismatched or unmatched closing bracket
                        errors.add(i);
                    } else {
                        stack.pop();
                    }
                }
            }
            
            // Mark any unmatched opening brackets as errors
            stack.forEach(item => errors.add(item.index));
            
            // Second pass: build the HTML with spans for each character
            const brackets = []; // Track current bracket stack: { char, index, isSeqBracket, level }
            let trackLevel = 0; // Track level for track brackets (t(), .play(), etc.)
            let seqLevel = 0; // Sequence level for sequence brackets ([...], .c(), etc.)
            let insideSeqBlock = false; // Track if we're currently inside a [ ... ] block
            
            // Helper to determine if a bracket is sequence-level
            function determineBracketType(char, lookback) {
                // [ and ] are ALWAYS sequence level, regardless of context
                if (char === '[' || char === ']') {
                    return { isSeq: true, reason: 'sequence-block' };
                }
                
                if (char === '(' || char === ')') {
                    // Sequence modifiers - these are always sequence level
                    const seqModifiers = ['.c', '.ds', '.co', '.nRange', '.vRange', '.dRange', '.nArp', '.vArp', '.dArp', '.pm', '.pr', '.v', '.d', '.p', '.n', '.a'];
                    // Track modifiers - these are always track level
                    const trackModifiers = ['.play', '.bpm', '.sn', '.sd', '.stop'];
                    
                    // Check what comes immediately before this bracket
                    const modifierMatch = lookback.match(/([a-zA-Z0-9_]+|\.\w+)\s*$/);
                    if (modifierMatch) {
                        const modifier = modifierMatch[1];
                        
                        // Check for function calls like n(, a(
                        if (modifier.match(/^(n|a)$/)) {
                            // n( or a( - check if inside sequence block
                            // Look for previous [ or ]
                            let inSeq = false;
                            let depth = 0;
                            for (let k = lookback.length - 1; k >= 0; k--) {
                                if (lookback[k] === ']') depth++;
                                else if (lookback[k] === '[') {
                                    depth--;
                                    if (depth === 0) {
                                        inSeq = true;
                                        break;
                                    }
                                }
                            }
                            return { isSeq: inSeq, reason: inSeq ? 'sequence-function' : 'track-function' };
                        }
                        
                        // Check for dot modifiers
                        if (modifier.startsWith('.')) {
                            if (seqModifiers.some(m => modifier === m)) {
                                return { isSeq: true, reason: 'sequence-modifier' };
                            } else if (trackModifiers.some(m => modifier === m)) {
                                return { isSeq: false, reason: 'track-modifier' };
                            }
                        }
                    }
                    
                    // Check if we're inside a sequence block [ ... ]
                    let bracketDepth = 0;
                    let foundSeqBlock = false;
                    for (let k = lookback.length - 1; k >= 0; k--) {
                        if (lookback[k] === ']') bracketDepth++;
                        else if (lookback[k] === '[') {
                            bracketDepth--;
                            if (bracketDepth === 0) {
                                foundSeqBlock = true;
                                break;
                            }
                        }
                    }
                    
                    // Check for track-level function calls first (before checking sequence block)
                    // Check if it's t(, .play(, .bpm(, .sn(, .sd(, .stop(
                    if (lookback.trim().match(/(t|\.play|\.bpm|\.sn|\.sd|\.stop)\s*\(\s*$/)) {
                        return { isSeq: false, reason: 'track-declaration-or-modifier' };
                    }
                    
                    if (foundSeqBlock) {
                        return { isSeq: true, reason: 'inside-sequence-block' };
                    }
                    
                    // Default to track level
                    return { isSeq: false, reason: 'default-track' };
                }
                
                return { isSeq: false, reason: 'unknown' };
            }
            
            for (let i = 0; i < line.length; i++) {
                const char = line[i];
                const nextChar = i < line.length - 1 ? line[i + 1] : '';
                
                // Check for comment start
                if (char === '/' && nextChar === '/') {
                    // Add rest of line character by character as normal text (comment)
                    for (let j = i; j < line.length; j++) {
                        const span = document.createElement('span');
                        span.className = 'char';
                        span.textContent = line[j];
                        result.appendChild(span);
                    }
                    break;
                }
                
                // Check if this character is an error
                const isError = errors.has(i);
                
                // Check if it's an opening bracket
                if (bracketChars[char]) {
                    const lookback = line.substring(0, i);
                    const bracketInfo = determineBracketType(char, lookback);
                    const isSeqBracket = bracketInfo.isSeq;
                    
                    let level;
                    // For [ brackets, ALWAYS sequence level 0, regardless of any previous state
                    if (char === '[') {
                        level = 0; // Always start sequence blocks at level 0
                        insideSeqBlock = true;
                        seqLevel = 1; // Next bracket inside [ will be at seqLevel 1
                    } else if (isSeqBracket) {
                        if (insideSeqBlock) {
                            level = seqLevel;
                            seqLevel++;
                        } else {
                            // Sequence modifier after ] block - reset and start at 0
                            level = 0;
                            seqLevel = 1;
                            insideSeqBlock = false; // Modifiers after ] are not "inside" the block
                        }
                    } else {
                        level = trackLevel;
                        trackLevel++;
                        // Track brackets are not inside sequence blocks
                        if (char === '(' && !isSeqBracket) {
                            insideSeqBlock = false;
                        }
                    }
                    
                    // Store bracket with its type and level
                    brackets.push({ char, index: i, isSeqBracket: isSeqBracket, level: level });
                    
                    const span = document.createElement('span');
                    span.className = isError ? 'bracket error' : 'bracket';
                    
                    if (isError) {
                        span.style.color = '#ff6b6b';
                    } else if (isSeqBracket) {
                        span.className += ` bracket-seq-${level % 4}`;
                    } else {
                        span.className += ` bracket-track-${level % 4}`;
                    }
                    
                    span.textContent = char;
                    result.appendChild(span);
                }
                // Check if it's a closing bracket
                else if (closingBrackets[char]) {
                    let matched = false;
                    if (brackets.length > 0) {
                        const lastBracket = brackets[brackets.length - 1];
                        if (closingBrackets[char] === lastBracket.char) {
                            // Use the stored level from the opening bracket
                            const wasSeqBracket = lastBracket.isSeqBracket;
                            const bracketLevel = lastBracket.level; // Use stored level, not current
                            brackets.pop();
                            
                            // Update levels AFTER using the stored level
                            if (wasSeqBracket) {
                                if (char === ']') {
                                    // Reset sequence level when closing a sequence block
                                    seqLevel = 0;
                                    insideSeqBlock = false;
                                } else {
                                    seqLevel = Math.max(0, seqLevel - 1);
                                }
                            } else {
                                trackLevel = Math.max(0, trackLevel - 1);
                            }
                            
                            matched = true;
                            const span = document.createElement('span');
                            span.className = isError ? 'bracket error' : 'bracket';
                            
                            if (isError) {
                                span.style.color = '#ff6b6b';
                            } else if (wasSeqBracket) {
                                span.className += ` bracket-seq-${bracketLevel % 4}`;
                            } else {
                                span.className += ` bracket-track-${bracketLevel % 4}`;
                            }
                            
                            span.textContent = char;
                            result.appendChild(span);
                        }
                    }
                    if (!matched) {
                        // Unmatched closing bracket
                        const span = document.createElement('span');
                        span.className = 'bracket error';
                        span.textContent = char;
                        result.appendChild(span);
                    }
                }
                // Regular character - wrap each one in a span
                else {
                    const span = document.createElement('span');
                    span.className = isError ? 'char error' : 'char';
                    span.textContent = char;
                    result.appendChild(span);
                }
            }
            
            return result;
        }
        
        // Update highlighting on any text change
        commandArea.addEventListener('input', () => {
            if (highlightOverlay) {
                highlightBrackets();
            }
        });
        
        commandArea.addEventListener('keyup', () => {
            if (highlightOverlay) {
                highlightBrackets();
            }
        });
        
        commandArea.addEventListener('paste', () => {
            setTimeout(() => {
                if (highlightOverlay) {
                    highlightBrackets();
                }
            }, 0);
        });
        
        // Also update on change event
        commandArea.addEventListener('change', () => {
            if (highlightOverlay) {
                highlightBrackets();
            }
        });
        
        // Sync scroll between textarea and overlay
        commandArea.addEventListener('scroll', () => {
            if (highlightOverlay) {
                highlightOverlay.scrollTop = commandArea.scrollTop;
                highlightOverlay.scrollLeft = commandArea.scrollLeft;
            }
        });
        
        // Initialize highlighting when DOM is ready
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', () => {
                initHighlighting();
            });
        } else {
            initHighlighting();
        }
        
        // Focus textarea on load and ensure highlighting is active
        window.addEventListener('load', () => {
            if (!highlightOverlay) {
                initHighlighting();
            }
            commandArea.focus();
            highlightBrackets();
        });
        
        // Cleanup on page unload
        window.addEventListener('beforeunload', () => {
            if (reconnectTimeout) {
                clearTimeout(reconnectTimeout);
            }
            if (ws) {
                ws.onclose = null; // Prevent reconnect on manual close
                ws.close();
            }
        });
    </script>
</body>
</html>


