<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ALiCA - Command Interface</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        'dark-bg': '#1a1a1a',
                        'dark-bg-alt': '#0f0f0f',
                        'dark-border': '#444',
                        'dark-text': '#e0e0e0',
                        'dark-text-muted': '#888',
                        'blue-accent': '#4a9eff',
                        'purple-accent': '#9c27b0',
                    },
                    fontFamily: {
                        'mono': ['Courier New', 'monospace'],
                    },
                }
            }
        }
    </script>
    <style>
        /* Custom scrollbar styling - Tailwind doesn't support this */
        ::-webkit-scrollbar {
            width: 12px;
            height: 12px;
        }
        ::-webkit-scrollbar-track {
            background: #1a1a1a;
            border-left: 1px solid #333;
        }
        ::-webkit-scrollbar-thumb {
            background: #444;
            border-radius: 6px;
            border: 2px solid #1a1a1a;
        }
        ::-webkit-scrollbar-thumb:hover {
            background: #555;
        }
        ::-webkit-scrollbar-thumb:active {
            background: #666;
        }
        #commandArea,
        #highlightOverlay {
            scrollbar-width: thin;
            scrollbar-color: #444 #1a1a1a;
        }
        #commandArea::selection {
            background: rgba(100, 150, 255, 0.3);
        }
        #hintSyntax::-webkit-scrollbar {
            width: 6px;
        }
        #hintSyntax::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 3px;
        }
        #hintSyntax::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.2);
            border-radius: 3px;
        }
        #hintSyntax::-webkit-scrollbar-thumb:hover {
            background: rgba(255, 255, 255, 0.3);
        }
        /* Syntax highlighting colors */
        #highlightOverlay .bracket {
            font-weight: bold;
        }
        #highlightOverlay .error {
            color: #ff6b6b;
            background: rgba(255, 107, 107, 0.1);
        }
        #highlightOverlay .trackHighlight {
            background: rgba(100, 200, 255, 0.3) !important;
            transition: background 0.3s ease-out;
        }
        .bracket-track-0 { color: #ff6b6b; }
        .bracket-track-1 { color: #feca57; }
        .bracket-track-2 { color: #ff9ff3; }
        .bracket-track-3 { color: #a29bfe; }
        .bracket-seq-0 { color: #00d2d3; }
        .bracket-seq-1 { color: #fd79a8; }
        .bracket-seq-2 { color: #fdcb6e; }
        .bracket-seq-3 { color: #55efc4; }
    </style>
</head>

<body class="font-mono bg-dark-bg text-dark-text h-screen overflow-hidden">
    <div id="header" class="flex fixed top-0 left-0 right-0 h-[50px] bg-dark-bg border-b border-dark-border flex items-center justify-between px-5 z-[1000] shadow-lg">
        <div id="headerLeft" class="flex items-center text-xl font-bold text-dark-text">
            <span class="brand text-xl">ALiCA</span>
            <span class="byline text-[11px] text-dark-text-muted ml-1.5 font-normal">by Zetvies</span>
        </div>
        <div id="headerMiddle" class="flex items-center gap-5 text-[13px] font-bold text-dark-text">
            <span id="bpmDisplay" class="text-blue-accent">BPM: --</span>
            <span id="signatureDisplay" class="text-purple-accent">Signature: --/--</span>
            <div id="beatSequencer" class="flex gap-1.5 items-center"></div>
        </div>
        <div id="headerRight" class="flex items-center">
            <div id="status" class="px-4 py-2 rounded text-xs font-bold bg-red-900/50 border border-red-700 text-red-300">Disconnected</div>
        </div>
    </div>
    <div id="hint" class="hidden fixed bottom-5 right-5 w-[500px] max-w-[calc(100vw-40px)] p-3 bg-black/85 rounded text-[11px] text-dark-text-muted z-[1000] shadow-xl">
        <div id="hintHeader" class="flex justify-between items-center mb-2">
            <span id="hintTitle" class="font-bold text-dark-text text-xs">Commands & Syntax</span>
            <button id="hintClose" class="bg-transparent border-none text-dark-text-muted text-base cursor-pointer p-0 w-5 h-5 flex items-center justify-center rounded transition-all hover:bg-white/10 hover:text-dark-text" title="Hide hints">Ã—</button>
        </div>
        <div id="hintContent" class="flex flex-col gap-4 text-[11px] leading-relaxed">
            <div class="hintSection flex flex-col gap-2">
                <div class="syntaxSectionTitle font-bold text-blue-accent text-xs mb-2">Commands:</div>
                <div class="hintCommandsGrid grid grid-cols-3 grid-rows-2 gap-2 gap-x-4">
                    <div class="hintItem flex flex-col items-start gap-0.5">
                        <span class="hintKey font-mono text-blue-accent font-bold whitespace-nowrap">Ctrl+/</span>
                        <span class="hintDesc text-gray-400 text-[10px]">Toggle Comment</span>
                    </div>
                    <div class="hintItem flex flex-col items-start gap-0.5">
                        <span class="hintKey font-mono text-blue-accent font-bold whitespace-nowrap">Ctrl+S</span>
                        <span class="hintDesc text-gray-400 text-[10px]">Loop Track in Next Cycle</span>
                    </div>
                    <div class="hintItem flex flex-col items-start gap-0.5">
                        <span class="hintKey font-mono text-blue-accent font-bold whitespace-nowrap">Ctrl+Shift+S</span>
                        <span class="hintDesc text-gray-400 text-[10px]">Loop Track Immediately</span>
                    </div>
                    <div class="hintItem flex flex-col items-start gap-0.5">
                        <span class="hintKey font-mono text-blue-accent font-bold whitespace-nowrap">Ctrl+H</span>
                        <span class="hintDesc text-gray-400 text-[10px]">Stop All Loops</span>
                    </div>
                    <div class="hintItem flex flex-col items-start gap-0.5">
                        <span class="hintKey font-mono text-blue-accent font-bold whitespace-nowrap">Ctrl+Enter</span>
                        <span class="hintDesc text-gray-400 text-[10px]">Play Track in Next Cycle</span>
                    </div>
                    <div class="hintItem flex flex-col items-start gap-0.5">
                        <span class="hintKey font-mono text-blue-accent font-bold whitespace-nowrap">Ctrl+Shift+Enter</span>
                        <span class="hintDesc text-gray-400 text-[10px]">Play Track Immediately</span>
                    </div>
                </div>
            </div>
            <div class="hintSection flex flex-col gap-2">
                <div class="syntaxSectionTitle font-bold text-blue-accent text-xs mb-2">Syntax:</div>
                <div id="hintSyntax" class="max-h-[400px] overflow-y-auto pr-1">
                    <div class="syntaxSection mb-4">
                        <div class="syntaxChain font-mono text-dark-text text-[10px] mb-1">t(cycleId).bpm(bpm).sn(num).sd(den).ds(delay).play([...])</div>
                        <div class="syntaxDesc text-gray-400 text-[10px] ml-3 mb-1.5 leading-snug">
                            <strong>t(cycleId):</strong> Track identifier (alphanumeric with _/-)<br>
                            <strong>.bpm(bpm):</strong> Override tempo (number or tmp*2/3*4)<br>
                            <strong>.sn(num):</strong> Time signature numerator (number or sn*2/3*4)<br>
                            <strong>.sd(den):</strong> Time signature denominator (number or sd*2/3*4)<br>
                            <strong>.ds(delay):</strong> Delay start - wait before starting cycle (bt, br, bt*2, br*2,
                            etc. or milliseconds). Can also come after .play()<br>
                            <strong>.play([...]):</strong> Sequence/automation blocks to play
                        </div>
                        <div class="syntaxExample font-mono text-blue-accent text-[9px] ml-3 mb-2 opacity-80">t(main).bpm(120).sn(4).sd(4).ds(bt*2).play([n(60)^4])</div>
                        <div class="syntaxExample font-mono text-blue-accent text-[9px] ml-3 mb-2 opacity-80">t(automation).play([n(60) n(65)].c(2)).ds(bt*2)</div>
                    </div>

                    <div class="syntaxSection mb-4">
                        <div class="syntaxChain font-mono text-dark-text text-[10px] mb-1">[sequence].t(type).c(channel).co(cutoff).pm(prob)</div>
                        <div class="syntaxDesc text-gray-400 text-[10px] ml-3 mb-1.5 leading-snug">
                            <strong>[sequence]:</strong> Notes/automation wrapped in brackets<br>
                            <strong>.t(type):</strong> Timing: fit (evenly in bar), beat (per beat), bar (per bar)<br>
                            <strong>.c(channel):</strong> MIDI channel 1-16 or array &lt;1,2,3&gt;<br>
                            <strong>.co(cutoff):</strong> Duration token for cutoff: bt, br, or with multipliers (bt*2,
                            br/2, etc.)<br>
                            <strong>.pm(prob):</strong> Mute probability 0-1 for entire sequence<br>
                            <strong>Note:</strong> Sequences can contain both notes and automation commands. Notes use Sequence MIDI output, automation uses Automation MIDI output.
                        </div>
                        <div class="syntaxExample font-mono text-blue-accent text-[9px] ml-3 mb-2 opacity-80">[n(60)^4 n(62)^4].t(fit).c(1).pm(0.2)</div>
                    </div>

                    <div class="syntaxSection mb-4">
                        <div class="syntaxSubsectionTitle font-bold text-purple-accent text-[11px] mb-1.5">1. Note Syntax:</div>
                        <div class="syntaxChain font-mono text-dark-text text-[10px] mb-1">n(value).d(duration).v(velocity).c(channel)</div>
                        <div class="syntaxDesc text-gray-400 text-[10px] ml-3 mb-1.5 leading-snug">
                            <strong>n(value):</strong> MIDI note (0-127), note token (c4, c#3), or randomizer<br>
                            <strong>.d(duration):</strong> Duration in ms, bt (duration of one beat)/br (duration of one
                            bar) tokens, optionally add multipliers (*2, /4)<br>
                            <strong>.v(velocity):</strong> Velocity 0-127 or randomizer<br>
                            <strong>.c(channel):</strong> MIDI channel 1-16 or randomizer<br>
                            <strong>Additional:</strong> .nRange(min, max), .vRange(min, max), .dRange(min, max),
                            .pm(prob), .pmRange(min, max), .pr(prob), .prRange(min, max), .nArp(mode), .vArp(mode),
                            .dArp(mode), .pmArp(mode), .prArp(mode)
                        </div>
                        <div class="syntaxExample font-mono text-blue-accent text-[9px] ml-3 mb-2 opacity-80">n(60).d(bt).v(80).c(1)</div>

                        <div class="syntaxSubsection ml-3 mb-3">
                            <div class="syntaxSubsectionTitle font-bold text-purple-accent text-[11px] mb-1.5">Randomizers:</div>
                            <div class="syntaxChain font-mono text-dark-text text-[10px] mb-1">r</div>
                            <div class="syntaxDesc text-gray-400 text-[10px] ml-3 mb-1.5 leading-snug">Random value (notes default C1-C8, velocity 0-127). Use with ranges:
                                .nRange(min, max), .vRange(min, max), .dRange(min, max), .pmRange(min, max),
                                .prRange(min, max)</div>
                            <div class="syntaxExample font-mono text-blue-accent text-[9px] ml-3 mb-2 opacity-80">n(r).nRange(c3, c5)<br>n(60).v(r).vRange(0.5,
                                1.0)<br>n(60).d(r).dRange(bt/4, bt*2)<br>n(60).pm(r).pmRange(0.2,
                                0.8)<br>n(60).pr(r).prRange(0.1, 0.3)</div>

                            <div class="syntaxChain font-mono text-dark-text text-[10px] mb-1">r.o{value1, value2, ...}</div>
                            <div class="syntaxDesc text-gray-400 text-[10px] ml-3 mb-1.5 leading-snug">Random selection from array. For notes, can use chord syntax:
                                &lt;c4,e4,g4&gt;, &lt;chord(c-maj7)&gt;, &lt;scale(c-ionian)&gt;. For duration, only
                                even multipliers/divisors allowed (bt/2, bt/4, bt*2, bt*4, etc.)</div>
                            <div class="syntaxExample font-mono text-blue-accent text-[9px] ml-3 mb-2 opacity-80">n(r.o{c4,d4,e4}) - notes<br>n(60).v(r.o{60,80,100,127}) -
                                velocity<br>n(60).d(r.o{bt/2,bt/4,bt}) -
                                duration<br>n(r.o{&lt;c4,e4,g4&gt;,&lt;chord(c-maj7)&gt;}) - chord
                                syntax<br>n(60).pm(r.o{0.2,0.5,0.8}) - mute probability</div>
                        </div>

                        <div class="syntaxSubsection ml-3 mb-3">
                            <div class="syntaxSubsectionTitle font-bold text-purple-accent text-[11px] mb-1.5">Chords:</div>
                            <div class="syntaxChain font-mono text-dark-text text-[10px] mb-1">chord(root-quality)</div>
                            <div class="syntaxDesc text-gray-400 text-[10px] ml-3 mb-1.5 leading-snug">
                                <strong>root:</strong> Note (c, d#, f, etc.)<br>
                                <strong>quality:</strong> Triads: maj, min, dim, aug, sus2, sus4 | 7th: maj7, min7, 7,
                                maj7#5, min7b5, dim7 | 9th: maj9, min9, 9, 9#5, min9b5, b9, #9 | 11th: maj11, min11, 11,
                                #11 | 13th: maj13, min13, 13, 13b9, 13#9, 13#11 | Add: add9, add11, 6, 69, min6, min69 |
                                Altered: alt, 7alt, no3, no5 | Sus: sus9, 7sus4
                            </div>
                            <div class="syntaxExample font-mono text-blue-accent text-[9px] ml-3 mb-2 opacity-80">n(r.o{chord(c-maj7)})</div>
                        </div>

                        <div class="syntaxSubsection ml-3 mb-3">
                            <div class="syntaxSubsectionTitle font-bold text-purple-accent text-[11px] mb-1.5">Scale and Chord Preset:</div>
                            <div class="syntaxChain font-mono text-dark-text text-[10px] mb-1">scale(root-mode)</div>
                            <div class="syntaxDesc text-gray-400 text-[10px] ml-3 mb-1.5 leading-snug">
                                <strong>root:</strong> Note (c, d#, f, etc.)<br>
                                <strong>mode:</strong> Modes: ionian, dorian, phrygian, lydian, mixolydian, aeolian,
                                locrian | Pentatonic: pentatonicMajor, pentatonicMinor, pentatonicBlues | Japanese:
                                iwato, in/insen, yo | Blues: bluesMajor, bluesMinor | Harmonic/Melodic: harmonicMinor,
                                melodicMinor, double-harmonic | Synthetic: whole-tone, diminished, augmented | Exotic:
                                enigmatic, neapolitan, hungarianMinor, persian, arabic<br>
                                <strong>.q(quality):</strong> Optional chord quality (any from chord qualities above)
                            </div>
                            <div class="syntaxExample font-mono text-blue-accent text-[9px] ml-3 mb-2 opacity-80">n(r.o{scale(c-ionian)}).nRange(c3, c5)</div>
                        </div>

                        <div class="syntaxSubsection ml-3 mb-3">
                            <div class="syntaxSubsectionTitle font-bold text-purple-accent text-[11px] mb-1.5">Arpeggiators:</div>
                            <div class="syntaxChain font-mono text-dark-text text-[10px] mb-1">.nArp(mode) | .vArp(mode) | .dArp(mode) | .pmArp(mode) |
                                .prArp(mode)</div>
                            <div class="syntaxDesc text-gray-400 text-[10px] ml-3 mb-1.5 leading-snug">
                                Control how array values are selected from <strong>r.o{...}</strong>. Each parameter has
                                its own independent arpeggiator.<br>
                                <strong>Modes:</strong> random (default), up (ascending), down (descending), up-down
                                (ascending then descending, seamless), down-up (descending then ascending, seamless)<br>
                                <strong>.nArp(mode):</strong> Controls note arrays including chords<br>
                                <strong>.vArp(mode):</strong> Controls velocity arrays<br>
                                <strong>.dArp(mode):</strong> Controls duration arrays<br>
                                <strong>.pmArp(mode):</strong> Controls mute probability arrays<br>
                                <strong>.prArp(mode):</strong> Controls remove probability arrays<br>
                                Arrays are sorted by value, then reordered by mode. Position cycles across chunks and
                                repeats.
                            </div>
                            <div class="syntaxExample font-mono text-blue-accent text-[9px] ml-3 mb-2 opacity-80">
                                n(r.o{c4,e4,g4}).nArp(up) - notes ascending<br>
                                n(r.o{&lt;chord(c-maj)&gt;,&lt;chord(f-maj)&gt;,&lt;chord(g-maj)&gt;})^3.nArp(up) -
                                chord progression<br>
                                n(60).v(r.o{0.3,0.6,0.9}).vArp(down) - velocity descending<br>
                                n(r.o{c4,e4,g4})^3.nArp(up) - cycles across repeats
                            </div>
                        </div>
                    </div>

                    <div class="syntaxSection mb-4">
                        <div class="syntaxSubsectionTitle font-bold text-purple-accent text-[11px] mb-1.5">2. Sequence Syntax:</div>
                        <div class="syntaxChain font-mono text-dark-text text-[10px] mb-1">n(value1) n(value2) n(value3)^repeat</div>
                        <div class="syntaxDesc text-gray-400 text-[10px] ml-3 mb-1.5 leading-snug">
                            Multiple notes form a sequence. Use ^N to repeat a note N times.
                        </div>
                        <div class="syntaxExample font-mono text-blue-accent text-[9px] ml-3 mb-2 opacity-80">n(60).d(bt) n(62).d(bt) n(64)^4</div>
                    </div>

                    <div class="syntaxSection mb-4">
                        <div class="syntaxSubsectionTitle font-bold text-purple-accent text-[11px] mb-1.5">4. Automation Syntax:</div>
                        <div class="syntaxChain font-mono text-dark-text text-[10px] mb-1">a(controller).from(value).to(value).d(duration).e(easing).c(channel)
                        </div>
                        <div class="syntaxDesc text-gray-400 text-[10px] ml-3 mb-1.5 leading-snug">
                            <strong>a(controller):</strong> MIDI CC number 0-127 (e.g., 7=Volume, 10=Pan, 74=Filter Cutoff)<br>
                            <strong>.from(value):</strong> Start value 0-127 (default: 0)<br>
                            <strong>.to(value):</strong> End value 0-127 (default: 127)<br>
                            <strong>.d(duration):</strong> Duration in ms or tokens: bt, br, or with multipliers (bt*2,
                            br/2, etc.) - smoothly interpolates from start to end over this duration<br>
                            <strong>.e(easing):</strong> Easing function: linear, easeIn, easeOut, easeInOut,
                            easeInQuad, easeOutQuad, easeInOutQuad, easeInCubic, easeOutCubic, easeInOutCubic (default:
                            linear)<br>
                            <strong>.c(channel):</strong> MIDI channel 1-16 (optional)<br>
                            <strong>Note:</strong> Automation uses separate MIDI output for smooth CC streaming. Values are interpolated at 50fps (20ms intervals) for fluid parameter control.
                        </div>
                        <div class="syntaxExample">[a(7).from(0).to(127).d(bt).e(easeInOut)].t(beat).c(1)</div>
                        <div class="syntaxExample">[a(74).from(0).to(127).d(br).e(easeOut)].t(beat).c(1) - Filter sweep</div>
                    </div>
                </div>
            </div>
        </div>
    </div>
    <div id="hintToggle" class="fixed bottom-5 right-5 w-10 h-10 rounded-full bg-black/70 border-2 border-dark-border text-dark-text-muted text-xl cursor-pointer hidden items-center justify-center z-[1000] transition-all hover:bg-black/90 hover:border-gray-600 hover:text-dark-text hover:scale-110 shadow-xl">?</div>
    <div id="editorContainer" class="relative w-full mt-[50px] h-[calc(100vh-50px)]">
        <div id="highlightOverlay" class="absolute top-0 left-0 w-full h-full p-5 m-0 bg-dark-bg-alt box-border font-mono text-sm leading-relaxed whitespace-pre overflow-x-auto overflow-y-hidden pointer-events-none z-[1] tab-[2] text-dark-text"></div>
        <textarea id="commandArea" class="w-full h-full p-5 bg-transparent border-none text-transparent font-mono text-sm leading-relaxed resize-none outline-none tab-[2] whitespace-pre overflow-x-auto relative z-[2] caret-dark-text placeholder:text-gray-600" placeholder="Type here to start..."></textarea>
    </div>

    <script>
        let ws = null;
        let reconnectTimeout = null;
        let reconnectAttempts = 0;
        const maxReconnectAttempts = Infinity; // Keep trying forever
        const reconnectDelay = 3000; // Start with 3 seconds
        const maxReconnectDelay = 30000; // Max 30 seconds
        const statusEl = document.getElementById('status');
        const commandArea = document.getElementById('commandArea');

        // Function to load content from URL parameter
        function loadContentFromUrl() {
            if (!commandArea) return;

            const urlParams = new URLSearchParams(window.location.search);
            const codeParam = urlParams.get('code');
            if (codeParam) {
                try {
                    const decoded = decodeURIComponent(codeParam);
                    commandArea.value = decoded;
                    // Trigger input event to update highlighting
                    commandArea.dispatchEvent(new Event('input', { bubbles: true }));
                } catch (e) {
                    console.error('Error decoding URL parameter:', e);
                }
            } else {
                // No code parameter, clear the textarea
                commandArea.value = '';
                commandArea.dispatchEvent(new Event('input', { bubbles: true }));
            }
        }

        // Load content from URL parameter on page load
        loadContentFromUrl();

        // Initialize history state with current content (if any) so we can navigate back
        if (commandArea && commandArea.value.trim()) {
            const content = commandArea.value;
            const encoded = encodeURIComponent(content);
            const newUrl = window.location.origin + window.location.pathname + '?code=' + encoded;
            // Replace current state with initial content so we have a baseline
            window.history.replaceState({ code: content, url: newUrl }, '', newUrl);
        } else {
            // No content initially, replace with empty state
            const newUrl = window.location.origin + window.location.pathname;
            window.history.replaceState({ code: '', url: newUrl }, '', newUrl);
        }

        // Handle browser history navigation (back/forward buttons or popstate)
        window.addEventListener('popstate', (e) => {
            // If state has code, use it; otherwise load from URL
            if (e.state && e.state.code !== undefined) {
                commandArea.value = e.state.code;
                commandArea.dispatchEvent(new Event('input', { bubbles: true }));
            } else {
                loadContentFromUrl();
            }
        });

        // Initialize highlighting immediately if elements exist
        if (commandArea) {
            // Wait a bit for overlay to be ready
            setTimeout(() => {
                const overlay = document.getElementById('highlightOverlay');
                if (overlay) {
                    highlightOverlay = overlay;
                    highlightBrackets();
                }
            }, 50);
        }

        function connect() {
            // Clear any existing reconnect timeout
            if (reconnectTimeout) {
                clearTimeout(reconnectTimeout);
                reconnectTimeout = null;
            }

            // Close existing connection if any
            if (ws) {
                ws.onclose = null; // Prevent infinite loop
                ws.close();
            }

            try {
                ws = new WebSocket(`ws://localhost:4254`);

                ws.onopen = () => {
                    statusEl.textContent = 'Connected';
                    statusEl.className = 'px-4 py-2 rounded text-xs font-bold bg-green-900/50 border border-green-700 text-green-300';
                    reconnectAttempts = 0; // Reset on successful connection
                    console.log('WebSocket connected');
                };

                ws.onclose = (event) => {
                    statusEl.textContent = 'Disconnected';
                    statusEl.className = 'px-4 py-2 rounded text-xs font-bold bg-red-900/50 border border-red-700 text-red-300';
                    console.log('WebSocket disconnected', event.code, event.reason);

                    // Attempt to reconnect (unless it was a clean close or manual close)
                    if (event.code !== 1000) { // 1000 = normal closure
                        scheduleReconnect();
                    }
                };

                ws.onerror = (error) => {
                    console.error('WebSocket error:', error);
                    statusEl.textContent = 'Error';
                    statusEl.className = 'px-4 py-2 rounded text-xs font-bold bg-red-900/50 border border-red-700 text-red-300';
                };

                ws.onmessage = (event) => {
                    const data = JSON.parse(event.data);
                    console.log('Received:', data);

                    // Handle BPM and signature updates
                    if (data.type === 'tempoAndSignature') {
                        updateAbletonInfo(data.tempo, data.signatureNumerator, data.signatureDenominator);
                        // Update sequencer when signature changes
                        if (data.signatureNumerator) {
                            updateBeatSequencer(data.signatureNumerator);
                        }
                    }

                    // Handle beat updates
                    if (data.type === 'beat' && data.beatNumber !== undefined) {
                        updateBeatIndicator(data.beatNumber, data.bar);
                    }
                };

            } catch (error) {
                console.error('Failed to create WebSocket:', error);
                scheduleReconnect();
            }
        }

        function scheduleReconnect() {
            // Don't schedule if already scheduled
            if (reconnectTimeout) return;

            reconnectAttempts++;

            // Calculate delay with exponential backoff (capped at maxReconnectDelay)
            const delay = Math.min(reconnectDelay * Math.pow(1.5, reconnectAttempts - 1), maxReconnectDelay);

            statusEl.textContent = `Reconnecting... (attempt ${reconnectAttempts})`;
            console.log(`Scheduling reconnect in ${delay}ms (attempt ${reconnectAttempts})`);

            reconnectTimeout = setTimeout(() => {
                reconnectTimeout = null;
                connect();
            }, delay);
        }

        // Initial connection
        connect();

        // Handle keyboard shortcuts
        commandArea.addEventListener('keydown', (e) => {
            const isCtrl = e.ctrlKey || e.metaKey;
            const isShift = e.shiftKey;
            const isAlt = e.altKey;

            // Tab = insert 3 spaces
            if (!isCtrl && !isAlt && e.key === 'Tab') {
                e.preventDefault();
                const start = commandArea.selectionStart;
                const end = commandArea.selectionEnd;
                const text = commandArea.value;
                const spaces = '   '; // 3 spaces

                // Insert spaces at cursor position
                commandArea.value = text.substring(0, start) + spaces + text.substring(end);
                // Set cursor position after inserted spaces
                commandArea.selectionStart = commandArea.selectionEnd = start + spaces.length;
                // Trigger input event for highlighting
                commandArea.dispatchEvent(new Event('input', { bubbles: true }));
                return;
            }

            // Auto-complete brackets: ( ) [ ] { } < >
            const bracketPairs = {
                '(': ')',
                '[': ']',
                '{': '}',
                '<': '>'
            };
            if (!isCtrl && !isAlt && bracketPairs.hasOwnProperty(e.key) && e.key.length === 1) {
                const start = commandArea.selectionStart;
                const end = commandArea.selectionEnd;
                const text = commandArea.value;
                const closingBracket = bracketPairs[e.key];

                if (start === end) {
                    // No text selected: Insert opening bracket and closing bracket
                    commandArea.value = text.substring(0, start) + e.key + closingBracket + text.substring(end);
                    // Position cursor between the brackets
                    commandArea.selectionStart = commandArea.selectionEnd = start + 1;
                } else {
                    // Text is selected: Wrap selected text in brackets
                    const selectedText = text.substring(start, end);
                    commandArea.value = text.substring(0, start) + e.key + selectedText + closingBracket + text.substring(end);
                    // Select the wrapped text (including brackets)
                    commandArea.selectionStart = start;
                    commandArea.selectionEnd = start + 1 + selectedText.length + 1;
                }

                // Trigger input event for highlighting
                commandArea.dispatchEvent(new Event('input', { bubbles: true }));
                e.preventDefault();
                return;
            }

            // Ctrl + Shift + S = playCycle for current track immediately
            // Check this FIRST to catch it before browser intercepts
            if (isCtrl && !isAlt && isShift && (e.code === 'KeyS' || e.key === 's' || e.key === 'S')) {
                e.preventDefault();
                e.stopPropagation();
                e.stopImmediatePropagation();
                console.log('Ctrl+Shift+S pressed - playing cycle immediately');
                highlightTrackBriefly();
                playCycleForCurrentTrack();
                return;
            }

            // Ctrl + / = toggle comment on selected lines
            if (isCtrl && !isAlt && !isShift && (e.key === '/' || e.key === '?')) {
                e.preventDefault();
                highlightTrackBriefly();
                toggleComment();
            }
            // Ctrl + H = clear all cycles
            else if (isCtrl && !isAlt && !isShift && e.key === 'h') {
                e.preventDefault();
                highlightAllText();
                clearAllCycles();
            }
            // Ctrl + S = save whole track (queue playCycle for current track + save to URL)
            else if (isCtrl && !isAlt && !isShift && e.key === 's') {
                e.preventDefault();
                highlightTrackBriefly();
                queuePlayCycleForCurrentTrack();

                // Save to URL parameter and push to history
                const content = commandArea.value;
                if (content.trim()) {
                    const encoded = encodeURIComponent(content);
                    const newUrl = window.location.origin + window.location.pathname + '?code=' + encoded;
                    // Push state with content for history navigation
                    window.history.pushState({ code: content, url: newUrl }, '', newUrl);
                }
            }
            // Ctrl + Z = undo (go back in history)
            else if (isCtrl && !isAlt && !isShift && (e.key === 'z' || e.key === 'Z')) {
                e.preventDefault();
                if (window.history.length > 1) {
                    window.history.back();
                }
            }
            // Ctrl + Y = redo (go forward in history)
            else if (isCtrl && !isAlt && !isShift && (e.key === 'y' || e.key === 'Y')) {
                e.preventDefault();
                window.history.forward();
            }
            // Enter between matching brackets = split into separate lines
            else if (!isCtrl && !isAlt && e.key === 'Enter') {
                const start = commandArea.selectionStart;
                const end = commandArea.selectionEnd;
                const text = commandArea.value;

                // Only handle if cursor is at single position (no selection)
                if (start === end && start > 0 && start < text.length) {
                    // Check if we're between matching brackets
                    const bracketPairs = {
                        '(': ')',
                        '[': ']',
                        '{': '}',
                        '<': '>'
                    };

                    // Find the opening bracket to the left
                    let openBracket = null;
                    let openPos = -1;
                    let depth = 0;
                    for (let i = start - 1; i >= 0; i--) {
                        const char = text[i];
                        if (bracketPairs.hasOwnProperty(char)) {
                            // Found an opening bracket
                            if (depth === 0) {
                                openBracket = char;
                                openPos = i;
                                break;
                            }
                            depth--;
                        } else if (Object.values(bracketPairs).includes(char)) {
                            // Found a closing bracket, increase depth
                            depth++;
                        }
                    }

                    if (openBracket && openPos !== -1) {
                        // Check if the next closing bracket matches
                        const closingBracket = bracketPairs[openBracket];
                        const afterCursor = text.substring(start);
                        const nextCloseMatch = afterCursor.match(new RegExp('^\\s*\\' + closingBracket));

                        if (nextCloseMatch) {
                            // Check if there's any content (including spaces/line breaks) between brackets
                            const between = text.substring(openPos + 1, start);
                            const hasContent = between.trim().length > 0 || between.includes('\n') || between.includes('\r');

                            // Only proceed if there's no content between brackets
                            if (!hasContent) {
                                e.preventDefault();

                                // Get indentation from the line with the opening bracket
                                const lineStart = text.lastIndexOf('\n', openPos) + 1;
                                const lineBeforeOpen = text.substring(lineStart, openPos);
                                const indent = lineBeforeOpen.match(/^(\s*)/)[1];

                                // Create the new content
                                const beforeOpen = text.substring(0, openPos + 1);
                                const afterClose = text.substring(start + nextCloseMatch[0].length);

                                // Build new text (no indentation on middle line)
                                const newText = beforeOpen + '\n' + '\n' + indent + closingBracket + afterClose;

                                // Update textarea
                                commandArea.value = newText;

                                // Position cursor on the middle line (empty line)
                                const cursorPos = beforeOpen.length + 1;
                                commandArea.selectionStart = commandArea.selectionEnd = cursorPos;

                                // Trigger input event for highlighting
                                commandArea.dispatchEvent(new Event('input', { bubbles: true }));
                                return;
                            }
                        }
                    }
                }
            }

            // Ctrl + Enter = queue playTrack for current track (SWAPPED)
            else if (isCtrl && !isAlt && !isShift && e.key === 'Enter') {
                e.preventDefault();
                highlightTrackBriefly();
                queuePlayTrackForCurrentTrack();
            }
            // Ctrl + Shift + Enter = playTrack for current track immediately
            else if (isCtrl && !isAlt && isShift && e.key === 'Enter') {
                e.preventDefault();
                highlightTrackBriefly();
                playTrackForCurrentTrack();
            }
        }, true); // Use capture phase to catch earlier

        // Also listen at window level as backup for Ctrl+Shift+S
        window.addEventListener('keydown', (e) => {
            const isCtrl = e.ctrlKey || e.metaKey;
            const isShift = e.shiftKey;
            const isAlt = e.altKey;

            // Ctrl + Shift + S = playCycle for current track immediately
            if (isCtrl && !isAlt && isShift && (e.code === 'KeyS' || e.key === 's' || e.key === 'S')) {
                // Only handle if the event target is the textarea or its parent
                const target = e.target;
                if (target === commandArea || commandArea.contains(target)) {
                    e.preventDefault();
                    e.stopPropagation();
                    e.stopImmediatePropagation();
                    console.log('Ctrl+Shift+S pressed (window handler) - playing cycle immediately');
                    highlightTrackBriefly();
                    playCycleForCurrentTrack();
                }
            }
        }, true);

        // Get selected text from textarea
        function getSelectedText() {
            const start = commandArea.selectionStart;
            const end = commandArea.selectionEnd;
            if (start === end) return null; // No selection
            return commandArea.value.substring(start, end);
        }

        // Toggle comment on selected lines
        function toggleComment() {
            const fullText = commandArea.value;
            const start = commandArea.selectionStart;
            const end = commandArea.selectionEnd;

            // Find the lines that contain the selection
            let lineStart = start;
            let lineEnd = end;

            // Find start of first line containing selection
            while (lineStart > 0 && fullText[lineStart - 1] !== '\n') {
                lineStart--;
            }

            // Find end of last line containing selection
            while (lineEnd < fullText.length && fullText[lineEnd] !== '\n') {
                lineEnd++;
            }

            // Get all lines in the selection
            const selectedText = fullText.substring(lineStart, lineEnd);
            const lines = selectedText.split('\n');

            // Determine if all selected lines are commented (to decide toggle direction)
            let allCommented = true;
            let someCommented = false;
            for (const line of lines) {
                const trimmed = line.trim();
                if (trimmed && !trimmed.startsWith('//')) {
                    allCommented = false;
                } else if (trimmed && trimmed.startsWith('//')) {
                    someCommented = true;
                }
            }

            // Process each line
            const processedLines = lines.map(line => {
                const trimmed = line.trim();

                // Empty line - return as-is
                if (!trimmed) return line;

                // If line starts with //, remove comment
                if (trimmed.startsWith('//')) {
                    // Remove // and any space after it, but preserve indentation
                    const commentIndex = line.indexOf('//');
                    const afterComment = line.substring(commentIndex + 2).trimStart();
                    const beforeComment = line.substring(0, commentIndex);
                    return beforeComment + afterComment;
                } else {
                    // Add // at the start (preserve indentation)
                    const leadingWhitespace = line.match(/^\s*/)[0];
                    const restOfLine = line.substring(leadingWhitespace.length);
                    return leadingWhitespace + '//' + restOfLine;
                }
            });

            // Replace the selected lines
            const newText = fullText.substring(0, lineStart) +
                processedLines.join('\n') +
                fullText.substring(lineEnd);

            // Update textarea
            commandArea.value = newText;

            // Restore selection (adjust for length changes)
            const lengthDiff = newText.length - fullText.length;
            commandArea.selectionStart = lineStart;
            commandArea.selectionEnd = lineEnd + lengthDiff;
        }

        // Get selected lines or line containing cursor
        function getSelectedLines() {
            const fullText = commandArea.value;
            const start = commandArea.selectionStart;
            const end = commandArea.selectionEnd;

            // Check if there's actual text selection (not just cursor position)
            const hasSelection = start !== end;

            if (hasSelection) {
                // Use actual selection boundaries
                let lineStart = start;
                let lineEnd = end;

                // Find start of first line containing selection
                while (lineStart > 0 && fullText[lineStart - 1] !== '\n') {
                    lineStart--;
                }

                // Find end of last line containing selection
                while (lineEnd < fullText.length && fullText[lineEnd] !== '\n') {
                    lineEnd++;
                }

                const selectedText = fullText.substring(lineStart, lineEnd);
                // Get all lines within selection, filtering empty and comments
                const lines = selectedText.split('\n').filter(line => {
                    const trimmed = line.trim();
                    return trimmed && !trimmed.startsWith('//');
                });

                if (lines.length === 0) return null;
                // Join all selected lines
                return lines.join(' ');
            } else {
                // No selection - use line containing cursor
                const cursorPos = start;
                let lineStart = cursorPos;
                let lineEnd = cursorPos;

                // Find start of line containing cursor
                while (lineStart > 0 && fullText[lineStart - 1] !== '\n') {
                    lineStart--;
                }

                // Find end of line containing cursor
                while (lineEnd < fullText.length && fullText[lineEnd] !== '\n') {
                    lineEnd++;
                }

                const lineText = fullText.substring(lineStart, lineEnd).trim();
                if (!lineText || lineText.startsWith('//')) return null;

                return lineText;
            }
        }

        // Remove comments (lines starting with //) from text
        function removeComments(text) {
            if (!text) return text;
            const lines = text.split('\n');
            const filteredLines = lines.map(line => {
                // Find // on the line and remove everything from // to end of line
                const commentIndex = line.indexOf('//');
                if (commentIndex !== -1) {
                    // Check if // is not inside quotes or within another token
                    // Simple check: if // appears, remove from that position to end of line
                    return line.substring(0, commentIndex);
                }
                return line;
            });
            return filteredLines.join('\n');
        }

        // Remove line breaks and normalize whitespace
        function normalizeWhitespace(text) {
            if (!text) return text;
            // Remove all newlines and normalize other whitespace
            return text.replace(/\n/g, '').replace(/\r/g, '').replace(/\s+/g, ' ').trim();
        }

        // Check if text matches t(...).stop() or t(...).play(...).stop() syntax
        function isStopSyntax(text) {
            if (!text) return false;
            const trimmed = text.trim().replace(/\s+/g, '');
            // Match: t(...).stop() or t(...).stop or t(...).play(...).stop() or t(...).play(...).stop
            const stopMatch = trimmed.match(/^t\([^)]+\)(?:\.(?:bpm|sn|sd)\([^)]+\))*(?:\.play\([^)]*\))?\.stop\(?\)?$/);
            return stopMatch !== null;
        }

        // Find all t(...).play(...) tracks in the text (handles modifiers like .bpm(), .sn(), .sd(), .ds())
        function findAllTracks(text) {
            if (!text) return [];
            const tracks = [];
            let searchStart = 0;
            
            while (true) {
                const tIndex = text.indexOf('t(', searchStart);
                if (tIndex === -1) break;
                
                // Find matching closing parenthesis for t(...)
                let tDepth = 1;
                let tPos = tIndex + 2; // After 't('
                while (tPos < text.length && tDepth > 0) {
                    if (text[tPos] === '(') tDepth++;
                    else if (text[tPos] === ')') tDepth--;
                    tPos++;
                }
                if (tDepth !== 0) {
                    // Unmatched parentheses, skip
                    searchStart = tIndex + 2;
                    continue;
                }
                
                // Now look for .play( after t(...) and any modifiers
                let pos = tPos;
                let inPlay = false;
                let playStartPos = -1;
                let playEndPos = -1;
                let depth = 0;
                
                while (pos < text.length) {
                    // Check for .play(, .bpm(, .sn(, .sd(, .ds(, or next t(
                    if (text.substring(pos).startsWith('.play(')) {
                        inPlay = true;
                        playStartPos = pos + 6; // Position after '.play('
                        pos += 6; // Skip '.play('
                        depth = 1;
                        continue;
                    } else if (text.substring(pos).startsWith('t(')) {
                        // Found another track start, stop here
                        break;
                    }
                    
                    if (text[pos] === '(') depth++;
                    else if (text[pos] === ')') {
                        depth--;
                        if (inPlay && depth === 0) {
                            // Found complete t(...).play(...)
                            playEndPos = pos + 1;
                            const track = text.substring(tIndex, playEndPos);
                            tracks.push({
                                track: track,
                                start: tIndex,
                                end: playEndPos
                            });
                            searchStart = playEndPos;
                            break;
                        }
                    }
                    pos++;
                }
                
                if (!inPlay || playEndPos === -1) {
                    // No complete track found, skip this t(
                    searchStart = tIndex + 2;
                }
            }
            
            return tracks;
        }

        // Find the t(...).play(...) or t(...).play(...).stop() wrapper that contains the cursor/selection
        function findCurrentTrack() {
            const fullText = commandArea.value;
            const cursorPos = commandArea.selectionStart;

            // Find the nearest t(...) before cursor
            let searchStart = 0;
            let bestMatch = null;
            let bestEnd = -1;

            while (true) {
                const tIndex = fullText.indexOf('t(', searchStart);
                if (tIndex === -1 || tIndex > cursorPos) break;

                // Find matching closing parenthesis for .play(...) and optionally .stop()
                let depth = 0;
                let pos = tIndex;
                let inPlay = false;
                let playStartPos = -1;
                let playEndPos = -1;

                while (pos < fullText.length) {
                    if (fullText.substring(pos).startsWith('.play(')) {
                        inPlay = true;
                        playStartPos = pos + 6; // Position after '.play('
                        pos += 6; // Skip '.play('
                        depth = 1;
                        continue;
                    }

                    if (fullText[pos] === '(') depth++;
                    else if (fullText[pos] === ')') {
                        depth--;
                        if (inPlay && depth === 0) {
                            // Found complete t(...).play(...)
                            playEndPos = pos + 1;

                            // Check for .stop() after .play(...)
                            let afterPlayPos = playEndPos;
                            // Skip whitespace
                            while (afterPlayPos < fullText.length && /\s/.test(fullText[afterPlayPos])) {
                                afterPlayPos++;
                            }

                            // Check if .stop() or .stop follows
                            if (fullText.substring(afterPlayPos).startsWith('.stop()')) {
                                const stopEnd = afterPlayPos + 7;
                                // Check if cursor is within this track including stop
                                if (cursorPos >= tIndex && cursorPos <= stopEnd) {
                                    bestMatch = fullText.substring(tIndex, stopEnd);
                                    bestEnd = stopEnd;
                                    break;
                                }
                            } else if (fullText.substring(afterPlayPos).startsWith('.stop')) {
                                const stopEnd = afterPlayPos + 6;
                                // Check if cursor is within this track including stop
                                if (cursorPos >= tIndex && cursorPos <= stopEnd) {
                                    bestMatch = fullText.substring(tIndex, stopEnd);
                                    bestEnd = stopEnd;
                                    break;
                                }
                            }

                            // Check if cursor is within this track (without stop)
                            if (cursorPos >= tIndex && cursorPos <= playEndPos) {
                                bestMatch = fullText.substring(tIndex, playEndPos);
                                bestEnd = playEndPos;
                                break;
                            }
                            break;
                        }
                    }
                    pos++;
                }

                searchStart = tIndex + 2;
            }

            // Also check for standalone t(...).stop() (without .play())
            if (!bestMatch || cursorPos > bestEnd) {
                searchStart = 0;
                while (true) {
                    const tIndex = fullText.indexOf('t(', searchStart);
                    if (tIndex === -1 || tIndex > cursorPos) break;

                    // Find the end of t(...)
                    let pos = tIndex + 2;
                    let depth = 1;
                    while (pos < fullText.length && depth > 0) {
                        if (fullText[pos] === '(') depth++;
                        else if (fullText[pos] === ')') depth--;
                        pos++;
                    }

                    if (depth === 0) {
                        // Check for .stop() after t(...)
                        let afterT = pos;
                        // Skip whitespace
                        while (afterT < fullText.length && /\s/.test(fullText[afterT])) {
                            afterT++;
                        }

                        // Check if .stop() or .stop follows
                        if (fullText.substring(afterT).startsWith('.stop()')) {
                            const stopEnd = afterT + 7;
                            if (cursorPos >= tIndex && cursorPos <= stopEnd) {
                                bestMatch = fullText.substring(tIndex, stopEnd);
                                bestEnd = stopEnd;
                                break;
                            }
                        } else if (fullText.substring(afterT).startsWith('.stop')) {
                            const stopEnd = afterT + 6;
                            if (cursorPos >= tIndex && cursorPos <= stopEnd) {
                                bestMatch = fullText.substring(tIndex, stopEnd);
                                bestEnd = stopEnd;
                                break;
                            }
                        }
                    }

                    searchStart = tIndex + 2;
                }
            }

            // Remove comments from the found track
            if (bestMatch) {
                bestMatch = removeComments(bestMatch);
            }

            return bestMatch;
        }

        // Find current track and return both the track string and its position in the text
        function findCurrentTrackWithPosition() {
            const fullText = commandArea.value;
            const cursorPos = commandArea.selectionStart;

            // Find the nearest t(...) before cursor
            let searchStart = 0;
            let bestMatch = null;
            let bestStart = -1;
            let bestEnd = -1;

            while (true) {
                const tIndex = fullText.indexOf('t(', searchStart);
                if (tIndex === -1 || tIndex > cursorPos) break;

                // Find matching closing parenthesis for .play(...) and optionally .stop()
                let depth = 0;
                let pos = tIndex;
                let inPlay = false;
                let playStartPos = -1;
                let playEndPos = -1;

                while (pos < fullText.length) {
                    if (fullText.substring(pos).startsWith('.play(')) {
                        inPlay = true;
                        playStartPos = pos + 6; // Position after '.play('
                        pos += 6; // Skip '.play('
                        depth = 1;
                        continue;
                    }

                    if (fullText[pos] === '(') depth++;
                    else if (fullText[pos] === ')') {
                        depth--;
                        if (inPlay && depth === 0) {
                            // Found complete t(...).play(...)
                            playEndPos = pos + 1;

                            // Check for .stop() after .play(...)
                            let afterPlayPos = playEndPos;
                            // Skip whitespace
                            while (afterPlayPos < fullText.length && /\s/.test(fullText[afterPlayPos])) {
                                afterPlayPos++;
                            }

                            // Check if .stop() or .stop follows
                            if (fullText.substring(afterPlayPos).startsWith('.stop()')) {
                                const stopEnd = afterPlayPos + 7;
                                // Check if cursor is within this track including stop
                                if (cursorPos >= tIndex && cursorPos <= stopEnd) {
                                    bestMatch = fullText.substring(tIndex, stopEnd);
                                    bestStart = tIndex;
                                    bestEnd = stopEnd;
                                    break;
                                }
                            } else if (fullText.substring(afterPlayPos).startsWith('.stop')) {
                                const stopEnd = afterPlayPos + 6;
                                // Check if cursor is within this track including stop
                                if (cursorPos >= tIndex && cursorPos <= stopEnd) {
                                    bestMatch = fullText.substring(tIndex, stopEnd);
                                    bestStart = tIndex;
                                    bestEnd = stopEnd;
                                    break;
                                }
                            }

                            // Check if cursor is within this track (without stop)
                            if (cursorPos >= tIndex && cursorPos <= playEndPos) {
                                bestMatch = fullText.substring(tIndex, playEndPos);
                                bestStart = tIndex;
                                bestEnd = playEndPos;
                                break;
                            }
                            break;
                        }
                    }
                    pos++;
                }

                searchStart = tIndex + 2;
            }

            // Also check for standalone t(...).stop() (without .play())
            if (!bestMatch || cursorPos > bestEnd) {
                searchStart = 0;
                while (true) {
                    const tIndex = fullText.indexOf('t(', searchStart);
                    if (tIndex === -1 || tIndex > cursorPos) break;

                    // Find the end of t(...)
                    let pos = tIndex + 2;
                    let depth = 1;
                    while (pos < fullText.length && depth > 0) {
                        if (fullText[pos] === '(') depth++;
                        else if (fullText[pos] === ')') depth--;
                        pos++;
                    }

                    if (depth === 0) {
                        // Check for .stop() after t(...)
                        let afterT = pos;
                        // Skip whitespace
                        while (afterT < fullText.length && /\s/.test(fullText[afterT])) {
                            afterT++;
                        }

                        // Check if .stop() or .stop follows
                        if (fullText.substring(afterT).startsWith('.stop()')) {
                            const stopEnd = afterT + 7;
                            if (cursorPos >= tIndex && cursorPos <= stopEnd) {
                                bestMatch = fullText.substring(tIndex, stopEnd);
                                bestStart = tIndex;
                                bestEnd = stopEnd;
                                break;
                            }
                        } else if (fullText.substring(afterT).startsWith('.stop')) {
                            const stopEnd = afterT + 6;
                            if (cursorPos >= tIndex && cursorPos <= stopEnd) {
                                bestMatch = fullText.substring(tIndex, stopEnd);
                                bestStart = tIndex;
                                bestEnd = stopEnd;
                                break;
                            }
                        }
                    }

                    searchStart = tIndex + 2;
                }
            }

            if (bestMatch && bestStart !== -1 && bestEnd !== -1) {
                return {
                    track: bestMatch,
                    start: bestStart,
                    end: bestEnd
                };
            }
            return null;
        }

        // Highlight the current track for a brief moment
        function highlightTrackBriefly() {
            if (!highlightOverlay) {
                highlightOverlay = document.getElementById('highlightOverlay');
                if (!highlightOverlay) return;
            }

            const trackInfo = findCurrentTrackWithPosition();
            if (!trackInfo) return;

            // Get all character spans in the overlay
            const chars = highlightOverlay.querySelectorAll('.char, .bracket, .error');

            if (chars.length === 0) return;

            const fullText = commandArea.value;
            const trackStart = trackInfo.start;
            const trackEnd = trackInfo.end;

            // Find spans that correspond to the track range
            // Since spans are in order and map 1:1 with characters, we can use position counting
            let charCount = 0;
            let startSpanIndex = -1;
            let endSpanIndex = -1;

            for (let i = 0; i < chars.length; i++) {
                const span = chars[i];
                const text = span.textContent || '';

                // Check if we've reached the start of the track
                if (startSpanIndex === -1 && charCount >= trackStart) {
                    startSpanIndex = i;
                }

                // Count characters (newlines count as 1)
                charCount += text.length || 1;

                // Check if we've passed the end of the track
                if (charCount >= trackEnd && endSpanIndex === -1) {
                    endSpanIndex = i;
                    break;
                }
            }

            // If we found the range, highlight all spans in between
            if (startSpanIndex !== -1) {
                const endIndex = endSpanIndex !== -1 ? endSpanIndex : chars.length;
                const spansToHighlight = [];

                for (let i = startSpanIndex; i <= endIndex && i < chars.length; i++) {
                    const span = chars[i];
                    span.classList.add('trackHighlight');
                    spansToHighlight.push(span);
                }

                // Remove highlight after 500ms
                setTimeout(() => {
                    spansToHighlight.forEach(span => {
                        span.classList.remove('trackHighlight');
                    });
                }, 500);
            }
        }

        // Highlight all text for a brief moment
        function highlightAllText() {
            if (!highlightOverlay) {
                highlightOverlay = document.getElementById('highlightOverlay');
                if (!highlightOverlay) return;
            }

            // Get all character spans in the overlay
            const chars = highlightOverlay.querySelectorAll('.char, .bracket, .error');

            if (chars.length === 0) return;

            // Highlight all spans
            const spansToHighlight = [];
            chars.forEach(span => {
                span.classList.add('trackHighlight');
                spansToHighlight.push(span);
            });

            // Remove highlight after 500ms
            setTimeout(() => {
                spansToHighlight.forEach(span => {
                    span.classList.remove('trackHighlight');
                });
            }, 500);
        }

        // Apply t() wrapper settings to a sequence string
        function applyWrapperSettings(sequenceStr, wrapperStr) {
            if (!wrapperStr || !wrapperStr.startsWith('t(')) {
                return sequenceStr; // No wrapper, return as-is
            }

            const parsed = parseMethodChain(wrapperStr);
            if (!parsed) return sequenceStr;

            // Extract cycleId and build new t() wrapper with sequence
            const match = wrapperStr.match(/^t\(([^)]+)\)/);
            if (!match) return sequenceStr;

            const cycleId = match[1];
            let result = `t(${cycleId})`;

            if (parsed.tempo !== null) result += `.bpm(${parsed.tempo})`;
            if (parsed.sn !== null) result += `.sn(${parsed.sn})`;
            if (parsed.sd !== null) result += `.sd(${parsed.sd})`;

            result += `.play(${sequenceStr})`;
            return result;
        }

        // Queue playCycle for selected lines
        function queuePlayCycleForSelection() {
            const selectedSeq = getSelectedLines();
            if (!selectedSeq) {
                console.warn('No valid sequence selected');
                return;
            }

            // Check if selected text is a stop command
            if (isStopSyntax(selectedSeq)) {
                const normalized = normalizeWhitespace(selectedSeq);
                sendToServer({
                    action: 'playTrack', // Use any action, server will detect stop syntax
                    cycleStr: normalized
                });
                return;
            }

            const wrapper = findCurrentTrack();
            const fullCommand = applyWrapperSettings(selectedSeq, wrapper);
            const cleanCommand = removeComments(fullCommand);
            const normalizedCommand = normalizeWhitespace(cleanCommand);

            // Check again after applying wrapper settings
            if (isStopSyntax(normalizedCommand)) {
                sendToServer({
                    action: 'playTrack', // Use any action, server will detect stop syntax
                    cycleStr: normalizedCommand
                });
                return;
            }

            const parsed = parseMethodChain(normalizedCommand);

            sendToServer({
                action: 'addCycleToQueue',
                id: null,
                cycleStr: normalizedCommand,
                tempo: parsed?.tempo || null,
                signatureNumerator: parsed?.sn || null,
                signatureDenominator: parsed?.sd || null
            });
        }

        // Queue playCycle for current track(s) - handles multiple tracks concurrently based on selection
        function queuePlayCycleForCurrentTrack() {
            const fullText = commandArea.value;
            const start = commandArea.selectionStart;
            const end = commandArea.selectionEnd;
            const hasSelection = start !== end;
            
            // Check if all text is selected
            const allTextSelected = hasSelection && start === 0 && end === fullText.length;
            
            if (!hasSelection) {
                // No selection: use single track behavior (current track at cursor)
                const track = findCurrentTrack();
                if (!track) {
                    console.warn('No t() track found at cursor');
                    return;
                }

                // Check if it's a stop command
                if (isStopSyntax(track)) {
                    const normalized = normalizeWhitespace(track);
                    sendToServer({
                        action: 'playTrack', // Use any action, server will detect stop syntax
                        cycleStr: normalized
                    });
                    return;
                }

                const cleanTrack = removeComments(track);
                const normalizedTrack = normalizeWhitespace(cleanTrack);
                const parsed = parseMethodChain(normalizedTrack);
                sendToServer({
                    action: 'addCycleToQueue',
                    id: null,
                    cycleStr: normalizedTrack,
                    tempo: parsed?.tempo || null,
                    signatureNumerator: parsed?.sn || null,
                    signatureDenominator: parsed?.sd || null
                });
                return;
            }
            
            // Has selection: check if selection contains multiple tracks
            const selectedText = fullText.substring(start, end);
            const selectedTracks = findAllTracks(selectedText);
            
            // Only use concurrent behavior if:
            // 1. All text is selected, OR
            // 2. Selection contains multiple tracks
            if (allTextSelected || selectedTracks.length > 1) {
                // Process all tracks concurrently
                const tracksToProcess = allTextSelected ? findAllTracks(fullText) : selectedTracks;
                console.log(`[QUEUE] Found ${tracksToProcess.length} track(s) in ${allTextSelected ? 'all text' : 'selection'}, queuing all concurrently`);
                
                tracksToProcess.forEach(trackInfo => {
                    const track = trackInfo.track;
                    
                    // Check if it's a stop command
                    if (isStopSyntax(track)) {
                        const normalized = normalizeWhitespace(track);
                        sendToServer({
                            action: 'playTrack', // Use any action, server will detect stop syntax
                            cycleStr: normalized
                        });
                        return;
                    }

                    const cleanTrack = removeComments(track);
                    const normalizedTrack = normalizeWhitespace(cleanTrack);
                    const parsed = parseMethodChain(normalizedTrack);
                    sendToServer({
                        action: 'addCycleToQueue',
                        id: null,
                        cycleStr: normalizedTrack,
                        tempo: parsed?.tempo || null,
                        signatureNumerator: parsed?.sn || null,
                        signatureDenominator: parsed?.sd || null
                    });
                });
            } else {
                // Single track in selection: use single track behavior
                const track = findCurrentTrack();
                if (!track) {
                    console.warn('No t() track found in selection');
                    return;
                }

                // Check if it's a stop command
                if (isStopSyntax(track)) {
                    const normalized = normalizeWhitespace(track);
                    sendToServer({
                        action: 'playTrack', // Use any action, server will detect stop syntax
                        cycleStr: normalized
                    });
                    return;
                }

                const cleanTrack = removeComments(track);
                const normalizedTrack = normalizeWhitespace(cleanTrack);
                const parsed = parseMethodChain(normalizedTrack);
                sendToServer({
                    action: 'addCycleToQueue',
                    id: null,
                    cycleStr: normalizedTrack,
                    tempo: parsed?.tempo || null,
                    signatureNumerator: parsed?.sn || null,
                    signatureDenominator: parsed?.sd || null
                });
            }
        }

        // Queue playTrack for selected lines
        function queuePlayTrackForSelection() {
            const selectedSeq = getSelectedLines();
            if (!selectedSeq) {
                console.warn('No valid sequence selected');
                return;
            }

            // Check if selected text is a stop command
            if (isStopSyntax(selectedSeq)) {
                sendToServer({
                    action: 'playTrack', // Use any action, server will detect stop syntax
                    cycleStr: selectedSeq
                });
                return;
            }

            const wrapper = findCurrentTrack();
            const fullCommand = applyWrapperSettings(selectedSeq, wrapper);
            const cleanCommand = removeComments(fullCommand);
            const normalizedCommand = normalizeWhitespace(cleanCommand);

            // Check again after applying wrapper settings
            if (isStopSyntax(normalizedCommand)) {
                sendToServer({
                    action: 'playTrack', // Use any action, server will detect stop syntax
                    cycleStr: normalizedCommand
                });
                return;
            }

            const parsed = parseMethodChain(normalizedCommand);

            sendToServer({
                action: 'addTrackToQueue',
                id: null,
                cycleStr: normalizedCommand,
                tempo: parsed?.tempo || null,
                signatureNumerator: parsed?.sn || null,
                signatureDenominator: parsed?.sd || null
            });
        }

        // Queue playTrack for current track(s) - handles multiple tracks concurrently based on selection
        function queuePlayTrackForCurrentTrack() {
            const fullText = commandArea.value;
            const start = commandArea.selectionStart;
            const end = commandArea.selectionEnd;
            const hasSelection = start !== end;
            
            // Check if all text is selected
            const allTextSelected = hasSelection && start === 0 && end === fullText.length;
            
            if (!hasSelection) {
                // No selection: use single track behavior (current track at cursor)
                const track = findCurrentTrack();
                if (!track) {
                    console.warn('No t() track found at cursor');
                    return;
                }

                // Check if it's a stop command
                if (isStopSyntax(track)) {
                    const normalized = normalizeWhitespace(track);
                    sendToServer({
                        action: 'playTrack', // Use any action, server will detect stop syntax
                        cycleStr: normalized
                    });
                    return;
                }

                const cleanTrack = removeComments(track);
                const normalizedTrack = normalizeWhitespace(cleanTrack);
                const parsed = parseMethodChain(normalizedTrack);
                sendToServer({
                    action: 'addTrackToQueue',
                    id: null,
                    cycleStr: normalizedTrack,
                    tempo: parsed?.tempo || null,
                    signatureNumerator: parsed?.sn || null,
                    signatureDenominator: parsed?.sd || null
                });
                return;
            }
            
            // Has selection: check if selection contains multiple tracks
            const selectedText = fullText.substring(start, end);
            const selectedTracks = findAllTracks(selectedText);
            
            // Only use concurrent behavior if:
            // 1. All text is selected, OR
            // 2. Selection contains multiple tracks
            if (allTextSelected || selectedTracks.length > 1) {
                // Process all tracks concurrently
                const tracksToProcess = allTextSelected ? findAllTracks(fullText) : selectedTracks;
                console.log(`[QUEUE] Found ${tracksToProcess.length} track(s) in ${allTextSelected ? 'all text' : 'selection'}, queuing all concurrently`);
                
                tracksToProcess.forEach(trackInfo => {
                    const track = trackInfo.track;
                    
                    // Check if it's a stop command
                    if (isStopSyntax(track)) {
                        const normalized = normalizeWhitespace(track);
                        sendToServer({
                            action: 'playTrack', // Use any action, server will detect stop syntax
                            cycleStr: normalized
                        });
                        return;
                    }

                    const cleanTrack = removeComments(track);
                    const normalizedTrack = normalizeWhitespace(cleanTrack);
                    const parsed = parseMethodChain(normalizedTrack);
                    sendToServer({
                        action: 'addTrackToQueue',
                        id: null,
                        cycleStr: normalizedTrack,
                        tempo: parsed?.tempo || null,
                        signatureNumerator: parsed?.sn || null,
                        signatureDenominator: parsed?.sd || null
                    });
                });
            } else {
                // Single track in selection: use single track behavior
                const track = findCurrentTrack();
                if (!track) {
                    console.warn('No t() track found in selection');
                    return;
                }

                // Check if it's a stop command
                if (isStopSyntax(track)) {
                    const normalized = normalizeWhitespace(track);
                    sendToServer({
                        action: 'playTrack', // Use any action, server will detect stop syntax
                        cycleStr: normalized
                    });
                    return;
                }

                const cleanTrack = removeComments(track);
                const normalizedTrack = normalizeWhitespace(cleanTrack);
                const parsed = parseMethodChain(normalizedTrack);
                sendToServer({
                    action: 'addTrackToQueue',
                    id: null,
                    cycleStr: normalizedTrack,
                    tempo: parsed?.tempo || null,
                    signatureNumerator: parsed?.sn || null,
                    signatureDenominator: parsed?.sd || null
                });
            }
        }

        // Play playCycle for selected lines (immediate)
        function playCycleForSelection() {
            const selectedSeq = getSelectedLines();
            if (!selectedSeq) {
                console.warn('No valid sequence selected');
                return;
            }

            // Check if selected text is a stop command
            if (isStopSyntax(selectedSeq)) {
                const normalized = normalizeWhitespace(selectedSeq);
                sendToServer({
                    action: 'playTrack', // Use any action, server will detect stop syntax
                    cycleStr: normalized
                });
                return;
            }

            const wrapper = findCurrentTrack();
            const fullCommand = applyWrapperSettings(selectedSeq, wrapper);
            const cleanCommand = removeComments(fullCommand);
            const normalizedCommand = normalizeWhitespace(cleanCommand);

            // Check again after applying wrapper settings
            if (isStopSyntax(normalizedCommand)) {
                sendToServer({
                    action: 'playTrack', // Use any action, server will detect stop syntax
                    cycleStr: normalizedCommand
                });
                return;
            }

            const parsed = parseMethodChain(normalizedCommand);

            sendToServer({
                action: 'playCycle',
                id: null,
                cycleStr: normalizedCommand,
                tempo: parsed?.tempo || null,
                signatureNumerator: parsed?.sn || null,
                signatureDenominator: parsed?.sd || null
            });
        }

        // Play playCycle for current track (immediate)
        function playCycleForCurrentTrack() {
            const track = findCurrentTrack();
            if (!track) {
                console.warn('No t() track found');
                return;
            }

            // Check if it's a stop command
            if (isStopSyntax(track)) {
                sendToServer({
                    action: 'playTrack', // Use any action, server will detect stop syntax
                    cycleStr: track
                });
                return;
            }

            const cleanTrack = removeComments(track);
            const normalizedTrack = normalizeWhitespace(cleanTrack);
            const parsed = parseMethodChain(normalizedTrack);
            sendToServer({
                action: 'playCycle',
                id: null,
                cycleStr: normalizedTrack,
                tempo: parsed?.tempo || null,
                signatureNumerator: parsed?.sn || null,
                signatureDenominator: parsed?.sd || null
            });
        }

        // Play playTrack for selected lines (immediate)
        function playTrackForSelection() {
            const selectedSeq = getSelectedLines();
            if (!selectedSeq) {
                console.warn('No valid sequence selected');
                return;
            }

            // Check if selected text is a stop command
            if (isStopSyntax(selectedSeq)) {
                const normalized = normalizeWhitespace(selectedSeq);
                sendToServer({
                    action: 'playTrack', // Use any action, server will detect stop syntax
                    cycleStr: normalized
                });
                return;
            }

            const wrapper = findCurrentTrack();
            const fullCommand = applyWrapperSettings(selectedSeq, wrapper);
            const cleanCommand = removeComments(fullCommand);
            const normalizedCommand = normalizeWhitespace(cleanCommand);

            // Check again after applying wrapper settings
            if (isStopSyntax(normalizedCommand)) {
                sendToServer({
                    action: 'playTrack', // Use any action, server will detect stop syntax
                    cycleStr: normalizedCommand
                });
                return;
            }

            const parsed = parseMethodChain(normalizedCommand);

            sendToServer({
                action: 'playTrack',
                id: null,
                cycleStr: normalizedCommand,
                tempo: parsed?.tempo || null,
                signatureNumerator: parsed?.sn || null,
                signatureDenominator: parsed?.sd || null
            });
        }

        // Play playTrack for current track(s) (immediate) - handles multiple tracks concurrently based on selection
        function playTrackForCurrentTrack() {
            const fullText = commandArea.value;
            const start = commandArea.selectionStart;
            const end = commandArea.selectionEnd;
            const hasSelection = start !== end;
            
            // Check if all text is selected
            const allTextSelected = hasSelection && start === 0 && end === fullText.length;
            
            if (!hasSelection) {
                // No selection: use single track behavior (current track at cursor)
                const track = findCurrentTrack();
                if (!track) {
                    console.warn('No t() track found at cursor');
                    return;
                }

                // Check if it's a stop command
                if (isStopSyntax(track)) {
                    const normalized = normalizeWhitespace(track);
                    sendToServer({
                        action: 'playTrack', // Use any action, server will detect stop syntax
                        cycleStr: normalized
                    });
                    return;
                }

                const cleanTrack = removeComments(track);
                const normalizedTrack = normalizeWhitespace(cleanTrack);
                const parsed = parseMethodChain(normalizedTrack);
                sendToServer({
                    action: 'playTrack',
                    id: null,
                    cycleStr: normalizedTrack,
                    tempo: parsed?.tempo || null,
                    signatureNumerator: parsed?.sn || null,
                    signatureDenominator: parsed?.sd || null
                });
                return;
            }
            
            // Has selection: check if selection contains multiple tracks
            const selectedText = fullText.substring(start, end);
            const selectedTracks = findAllTracks(selectedText);
            
            // Only use concurrent behavior if:
            // 1. All text is selected, OR
            // 2. Selection contains multiple tracks
            if (allTextSelected || selectedTracks.length > 1) {
                // Process all tracks concurrently
                const tracksToProcess = allTextSelected ? findAllTracks(fullText) : selectedTracks;
                console.log(`[PLAY] Found ${tracksToProcess.length} track(s) in ${allTextSelected ? 'all text' : 'selection'}, playing all concurrently`);
                
                tracksToProcess.forEach(trackInfo => {
                    const track = trackInfo.track;
                    
                    // Check if it's a stop command
                    if (isStopSyntax(track)) {
                        const normalized = normalizeWhitespace(track);
                        sendToServer({
                            action: 'playTrack', // Use any action, server will detect stop syntax
                            cycleStr: normalized
                        });
                        return;
                    }

                    const cleanTrack = removeComments(track);
                    const normalizedTrack = normalizeWhitespace(cleanTrack);
                    const parsed = parseMethodChain(normalizedTrack);
                    sendToServer({
                        action: 'playTrack',
                        id: null,
                        cycleStr: normalizedTrack,
                        tempo: parsed?.tempo || null,
                        signatureNumerator: parsed?.sn || null,
                        signatureDenominator: parsed?.sd || null
                    });
                });
            } else {
                // Single track in selection: use single track behavior
                const track = findCurrentTrack();
                if (!track) {
                    console.warn('No t() track found in selection');
                    return;
                }

                // Check if it's a stop command
                if (isStopSyntax(track)) {
                    const normalized = normalizeWhitespace(track);
                    sendToServer({
                        action: 'playTrack', // Use any action, server will detect stop syntax
                        cycleStr: normalized
                    });
                    return;
                }

                const cleanTrack = removeComments(track);
                const normalizedTrack = normalizeWhitespace(cleanTrack);
                const parsed = parseMethodChain(normalizedTrack);
                sendToServer({
                    action: 'playTrack',
                    id: null,
                    cycleStr: normalizedTrack,
                    tempo: parsed?.tempo || null,
                    signatureNumerator: parsed?.sn || null,
                    signatureDenominator: parsed?.sd || null
                });
            }
        }

        // Join multi-line commands by tracking parentheses depth
        function joinMultiLineCommand(text) {
            const lines = text.split('\n');
            const commands = [];
            let currentCommand = '';
            let parenDepth = 0;
            let inString = false;
            let stringChar = null;

            for (const line of lines) {
                const trimmed = line.trim();

                // Skip empty lines and comments (but only when not in the middle of a command)
                if (!trimmed || trimmed.startsWith('//')) {
                    if (currentCommand && parenDepth === 0) {
                        commands.push(currentCommand.trim());
                        currentCommand = '';
                    }
                    continue;
                }

                // Track parentheses and strings across the entire line
                for (let i = 0; i < line.length; i++) {
                    const char = line[i];
                    const prevChar = i > 0 ? line[i - 1] : null;

                    if (!inString && (char === '"' || char === "'")) {
                        inString = true;
                        stringChar = char;
                    } else if (inString && char === stringChar && prevChar !== '\\') {
                        inString = false;
                        stringChar = null;
                    } else if (!inString) {
                        if (char === '(') parenDepth++;
                        else if (char === ')') parenDepth--;
                    }
                }

                // Add line to current command
                if (currentCommand) {
                    currentCommand += ' ' + trimmed;
                } else {
                    currentCommand = trimmed;
                }

                // If we've closed all parentheses and not in a string, command is complete
                if (parenDepth === 0 && !inString && currentCommand) {
                    commands.push(currentCommand.trim());
                    currentCommand = '';
                    parenDepth = 0;
                }
            }

            // Add any remaining command
            if (currentCommand.trim()) {
                commands.push(currentCommand.trim());
            }

            return commands.filter(cmd => cmd.length > 0);
        }

        // Split text into individual commands (now simplified since joinMultiLineCommand handles it)
        function splitCommands(text) {
            // The joinMultiLineCommand already returns an array of commands
            // But if text wasn't processed, split by newlines and filter
            const commands = Array.isArray(text) ? text : [text];
            return commands.filter(cmd => cmd.trim() && !cmd.trim().startsWith('//'));
        }

        // Helper function to evaluate chained multiplication/division expressions
        // Supports: baseValue*2/3*4, where baseValue can be tmp, sn, sd, or a number
        function evaluateExpression(expr, context = {}) {
            if (!expr || typeof expr !== 'string') return null;

            const norm = expr.trim().toLowerCase();

            // Parse base value: tmp, sn, sd, or a number
            let baseValue = null;
            let remainingExpr = '';

            if (norm === 'tmp' && context.tmp !== undefined && context.tmp !== null) {
                baseValue = context.tmp;
            } else if (norm === 'sn' && context.sn !== undefined && context.sn !== null) {
                baseValue = context.sn;
            } else if (norm === 'sd' && context.sd !== undefined && context.sd !== null) {
                baseValue = context.sd;
            } else if (norm.startsWith('tmp')) {
                if (context.tmp !== undefined && context.tmp !== null) {
                    baseValue = context.tmp;
                    remainingExpr = norm.substring(3); // Remove 'tmp' prefix
                }
            } else if (norm.startsWith('sn')) {
                if (context.sn !== undefined && context.sn !== null) {
                    baseValue = context.sn;
                    remainingExpr = norm.substring(2); // Remove 'sn' prefix
                }
            } else if (norm.startsWith('sd')) {
                if (context.sd !== undefined && context.sd !== null) {
                    baseValue = context.sd;
                    remainingExpr = norm.substring(2); // Remove 'sd' prefix
                }
            } else {
                // Try to parse as a number
                const numMatch = norm.match(/^(\d+(?:\.\d+)?)/);
                if (numMatch) {
                    baseValue = parseFloat(numMatch[1]);
                    remainingExpr = norm.substring(numMatch[1].length);
                }
            }

            if (baseValue === null || isNaN(baseValue)) return null;

            // If no remaining expression, return base value
            if (!remainingExpr) return baseValue;

            // Parse and apply operations from left to right
            // Pattern: *N or /N, where N can be any number
            const operationRegex = /([*\/])(\d+(?:\.\d+)?)/g;
            let result = baseValue;
            let match;
            let lastIndex = 0;

            while ((match = operationRegex.exec(remainingExpr)) !== null) {
                // Check that we're starting where we left off (no gaps)
                if (match.index !== lastIndex) {
                    return null; // Invalid - there's text between operations
                }

                const op = match[1];
                const num = parseFloat(match[2]);

                if (isNaN(num) || num <= 0) return null; // Invalid operation

                if (op === '*') {
                    result = result * num;
                } else if (op === '/') {
                    result = result / num;
                }

                lastIndex = match.index + match[0].length;
            }

            // Check if we consumed the entire expression
            if (lastIndex !== remainingExpr.length) {
                // There's extra text that wasn't consumed - invalid expression
                return null;
            }

            return result;
        }

        // Simple parser for new syntax (client-side helper)
        function parseMethodChain(str) {
            if (!str || !str.trim().startsWith('t(')) return null;

            const match = str.match(/^t\(([^)]+)\)/);
            if (!match) return null;

            const cycleId = match[1].trim();
            let bpm = null, sn = null, sd = null;

            // Parse .bpm(...)
            const bpmMatch = str.match(/\.bpm\(([^)]+)\)/);
            if (bpmMatch) {
                const bpmStr = bpmMatch[1].trim();
                // Support tmp*2/3*4 syntax where tmp is Ableton tempo, or regular number*2/3*4
                const exprResult = evaluateExpression(bpmStr.toLowerCase(), { tmp: currentAbletonTempo });
                if (exprResult !== null && !isNaN(exprResult) && exprResult > 0) {
                    bpm = exprResult;
                }
            }

            // Parse .sn(...)
            const snMatch = str.match(/\.sn\(([^)]+)\)/);
            if (snMatch) {
                const snStr = snMatch[1].trim();
                // Support sn*2/3*4 syntax where sn is Ableton signature numerator, or regular number*2/3*4
                const exprResult = evaluateExpression(snStr.toLowerCase(), { sn: currentAbletonSignatureNumerator });
                if (exprResult !== null && !isNaN(exprResult) && exprResult > 0) {
                    sn = Math.round(exprResult);
                }
            }

            // Parse .sd(...)
            const sdMatch = str.match(/\.sd\(([^)]+)\)/);
            if (sdMatch) {
                const sdStr = sdMatch[1].trim();
                // Support sd*2/3*4 syntax where sd is Ableton signature denominator, or regular number*2/3*4
                const exprResult = evaluateExpression(sdStr.toLowerCase(), { sd: currentAbletonSignatureDenominator });
                if (exprResult !== null && !isNaN(exprResult) && exprResult > 0) {
                    sd = Math.round(exprResult);
                }
            }

            return { cycleId, tempo: bpm, sn, sd };
        }

        // Update Ableton info display
        let currentBeatNumber = 0;
        let currentBarNumber = 0;
        let currentAbletonTempo = null; // Store current Ableton tempo for tmp*f syntax
        let currentAbletonSignatureNumerator = null; // Store for sn*f syntax
        let currentAbletonSignatureDenominator = null; // Store for sd*f syntax

        function updateAbletonInfo(bpm, numerator, denominator) {
            // Store tempo for tmp*f syntax support
            if (bpm !== null && bpm !== undefined) {
                currentAbletonTempo = bpm;
            }
            // Store signature for sn*f and sd*f syntax support
            if (numerator !== null && numerator !== undefined) {
                currentAbletonSignatureNumerator = numerator;
            }
            if (denominator !== null && denominator !== undefined) {
                currentAbletonSignatureDenominator = denominator;
            }
            const bpmDisplay = document.getElementById('bpmDisplay');
            const signatureDisplay = document.getElementById('signatureDisplay');

            if (bpm !== null && bpm !== undefined) {
                bpmDisplay.textContent = `BPM: ${Math.round(bpm)}`;
            } else {
                bpmDisplay.textContent = 'Please open Max4Live plugin in Ableton';
            }

            if (numerator !== null && numerator !== undefined && denominator !== null && denominator !== undefined) {
                signatureDisplay.textContent = `Signature: ${numerator}/${denominator}`;
                updateBeatSequencer(numerator);
            } else {
                signatureDisplay.textContent = '';
            }
        }

        // Create/update beat sequencer circles
        function updateBeatSequencer(beatsPerBar) {
            const sequencer = document.getElementById('beatSequencer');
            sequencer.innerHTML = '';

            for (let i = 1; i <= beatsPerBar; i++) {
                const circle = document.createElement('div');
                circle.className = 'w-2.5 h-2.5 rounded-full bg-dark-border border border-gray-600 transition-all duration-100';
                circle.id = `beat-${i}`;
                sequencer.appendChild(circle);
            }

            // Update active beat if we have current beat info
            if (currentBeatNumber > 0) {
                updateBeatIndicator(currentBeatNumber, currentBarNumber);
            }
        }

        // Update which beat circle is active
        function updateBeatIndicator(beatNumber, barNumber) {
            currentBeatNumber = beatNumber;
            currentBarNumber = barNumber || 0;

            // Remove active class from all circles
            document.querySelectorAll('[id^="beat-"]').forEach(circle => {
                circle.classList.remove('bg-blue-accent', 'shadow-[0_0_8px_#4a9eff]', 'border-blue-400', 'scale-125');
                circle.classList.add('bg-dark-border', 'border-gray-600');
            });

            // Add active class to current beat
            const activeCircle = document.getElementById(`beat-${beatNumber}`);
            if (activeCircle) {
                activeCircle.classList.remove('bg-dark-border', 'border-gray-600');
                activeCircle.classList.add('bg-blue-accent', 'shadow-[0_0_8px_#4a9eff]', 'border-blue-400', 'scale-125');
            }
        }

        // Helper function to send messages with connection check
        function sendToServer(data) {
            if (ws && ws.readyState === WebSocket.OPEN) {
                ws.send(JSON.stringify(data));
            } else {
                console.warn('WebSocket not connected, message queued:', data);
                // Optionally queue messages for when connection is restored
                // For now, just log a warning
                statusEl.textContent = 'Not Connected - Retrying...';
                statusEl.className = 'status disconnected';
            }
        }

        function clearAllCycles() {
            sendToServer({
                action: 'clearAllCycles'
            });
            console.log('Clear all cycles requested');
        }

        // Syntax highlighting for brackets/parentheses
        let highlightOverlay = null;

        // Initialize overlay after DOM is ready
        function initHighlighting() {
            highlightOverlay = document.getElementById('highlightOverlay');
            if (highlightOverlay && commandArea) {
                highlightBrackets();
            }
        }

        function highlightBrackets() {
            if (!highlightOverlay) {
                // Try to get overlay if not set
                highlightOverlay = document.getElementById('highlightOverlay');
                if (!highlightOverlay) return;
            }

            const text = commandArea.value || '';

            // Process entire text for multiline bracket matching
            const highlighted = highlightText(text);

            // Clear overlay and add highlighted content
            highlightOverlay.innerHTML = '';
            if (highlighted) {
                highlightOverlay.appendChild(highlighted);
            }
        }

        function highlightText(text) {
            if (!text) {
                return document.createDocumentFragment();
            }

            // First, process the entire text as a whole for bracket context
            // Then highlight character by character while maintaining line structure
            return highlightTextWithContext(text);
        }

        function highlightTextWithContext(text) {
            const result = document.createDocumentFragment();
            const bracketChars = { '(': ')', '[': ']', '{': '}', '<': '>' };
            const closingBrackets = { ')': '(', ']': '[', '}': '{', '>': '<' };

            // Process entire text for bracket matching across lines
            const lines = text.split('\n');
            const fullText = text;

            // Track bracket state across all lines
            const brackets = []; // Track current bracket stack: { char, index, isSeqBracket, level }
            let trackLevel = 0; // Track level for track brackets (t(), .play(), etc.)
            let seqLevel = 0; // Sequence level for sequence brackets ([...], .c(), etc.)
            let insideSeqBlock = false; // Track if we're currently inside a [ ... ] block

            // First pass: validate brackets across entire text
            const errors = new Set();
            const stack = [];
            let charIndex = 0;

            for (let lineIndex = 0; lineIndex < lines.length; lineIndex++) {
                const line = lines[lineIndex];
                for (let i = 0; i < line.length; i++) {
                    const char = line[i];
                    const nextChar = i < line.length - 1 ? line[i + 1] : '';

                    // Skip comments
                    if (char === '/' && nextChar === '/') {
                        break;
                    }

                    if (bracketChars[char]) {
                        stack.push({ char, index: charIndex });
                    } else if (closingBrackets[char]) {
                        if (stack.length === 0 || closingBrackets[char] !== stack[stack.length - 1].char) {
                            errors.add(charIndex);
                        } else {
                            stack.pop();
                        }
                    }
                    charIndex++;
                }
                charIndex++; // For newline
            }

            // Mark unmatched opening brackets
            stack.forEach(item => errors.add(item.index));

            // Helper to determine bracket type - now uses full text context
            function determineBracketType(char, globalIndex) {
                // [ and ] are ALWAYS sequence level
                if (char === '[' || char === ']') {
                    return { isSeq: true, reason: 'sequence-block' };
                }

                if (char === '(' || char === ')') {
                    const lookback = fullText.substring(0, globalIndex);

                    // Sequence modifiers
                    const seqModifiers = ['.c', '.co', '.nRange', '.vRange', '.dRange', '.nArp', '.vArp', '.dArp', '.pm', '.pr', '.v', '.d', '.p', '.n', '.a'];
                    // Track modifiers
                    const trackModifiers = ['.play', '.bpm', '.sn', '.sd', '.ds', '.stop'];

                    // Check what comes immediately before this bracket
                    const modifierMatch = lookback.match(/([a-zA-Z0-9_]+|\.\w+)\s*$/);
                    if (modifierMatch) {
                        const modifier = modifierMatch[1];

                        // Check for function calls like n(, a(
                        if (modifier.match(/^(n|a)$/)) {
                            // n( or a( - check if inside sequence block
                            let inSeq = false;
                            let depth = 0;
                            for (let k = lookback.length - 1; k >= 0; k--) {
                                if (lookback[k] === ']') depth++;
                                else if (lookback[k] === '[') {
                                    depth--;
                                    if (depth === 0) {
                                        inSeq = true;
                                        break;
                                    }
                                }
                            }
                            return { isSeq: inSeq, reason: inSeq ? 'sequence-function' : 'track-function' };
                        }

                        // Check for dot modifiers
                        if (modifier.startsWith('.')) {
                            if (seqModifiers.some(m => modifier === m)) {
                                return { isSeq: true, reason: 'sequence-modifier' };
                            } else if (trackModifiers.some(m => modifier === m)) {
                                return { isSeq: false, reason: 'track-modifier' };
                            }
                        }
                    }

                    // Check for track-level function calls FIRST (before checking sequence blocks)
                    // This ensures t(), .play(), etc. are always track-level even after sequence blocks
                    const lookbackTrimmed = lookback.trim();
                    const lookbackNoWS = lookback.replace(/\s+/g, '');

                    // Check if this is t( - remove whitespace for matching
                    if (lookbackNoWS.match(/t$/)) {
                        return { isSeq: false, reason: 'track-declaration-t' };
                    }

                    // Check for other track-level functions
                    if (lookbackTrimmed.match(/(\.play|\.bpm|\.sn|\.sd|\.ds|\.stop)\s*\(\s*$/)) {
                        return { isSeq: false, reason: 'track-declaration-or-modifier' };
                    }

                    // Check if we're inside a sequence block [ ... ]
                    let bracketDepth = 0;
                    let foundSeqBlock = false;
                    for (let k = lookback.length - 1; k >= 0; k--) {
                        if (lookback[k] === ']') bracketDepth++;
                        else if (lookback[k] === '[') {
                            bracketDepth--;
                            if (bracketDepth === 0) {
                                foundSeqBlock = true;
                                break;
                            }
                        }
                    }

                    if (foundSeqBlock) {
                        return { isSeq: true, reason: 'inside-sequence-block' };
                    }

                    // Default to track level
                    return { isSeq: false, reason: 'default-track' };
                }

                return { isSeq: false, reason: 'unknown' };
            }

            // Second pass: highlight character by character
            charIndex = 0;
            for (let lineIndex = 0; lineIndex < lines.length; lineIndex++) {
                const line = lines[lineIndex];

                for (let i = 0; i < line.length; i++) {
                    const char = line[i];
                    const nextChar = i < line.length - 1 ? line[i + 1] : '';

                    // Check for comment start
                    if (char === '/' && nextChar === '/') {
                        // Add rest of line as plain text
                        for (let j = i; j < line.length; j++) {
                            const span = document.createElement('span');
                            span.className = 'char';
                            span.textContent = line[j];
                            result.appendChild(span);
                        }
                        charIndex += (line.length - i);
                        break;
                    }

                    // Check if this character is an error
                    const isError = errors.has(charIndex);

                    // Check if it's an opening bracket
                    if (bracketChars[char]) {
                        const bracketInfo = determineBracketType(char, charIndex);
                        const isSeqBracket = bracketInfo.isSeq;

                        // Check if this is part of a chain inside a sequence block
                        // All chained items (.nRange(), .nArp(), .n(), .a(), etc.) should share level 1 with n()/a()
                        let isModifier = false;
                        let modifierParentLevel = null;
                        let isModifierAfterBracket = false; // Track if modifier comes right after ]
                        
                        // Check if this is a sequence modifier that comes right after ]
                        if (char === '(' && isSeqBracket && !insideSeqBlock) {
                            const lookbackRaw = fullText.substring(0, charIndex);
                            const lookbackNoWS = lookbackRaw.replace(/\s+/g, '');
                            // Check if this modifier comes right after ]
                            const modifierAfterBracketMatch = lookbackNoWS.match(/\]\.(?:c|co|nRange|vRange|dRange|nArp|vArp|dArp|pm|pr|v|d|p|n|a)$/);
                            if (modifierAfterBracketMatch) {
                                isModifierAfterBracket = true;
                                isModifier = true;
                                modifierParentLevel = 0; // Same level as brackets
                            }
                        }
                        
                        if (char === '(' && isSeqBracket && insideSeqBlock) {
                            // Look back to see if this is a modifier or chained function
                            // Get text before this position, remove all whitespace for matching
                            const lookbackRaw = fullText.substring(0, charIndex);
                            const lookbackNoWS = lookbackRaw.replace(/\s+/g, '');

                            // Match modifiers like .c, .co, .nRange, .nArp, etc. at the end of the lookback
                            const modifierMatch = lookbackNoWS.match(/(\.(?:c|co|nRange|vRange|dRange|nArp|vArp|dArp|pm|pr|v|d|p))$/);

                            // Also check if this is .n() or .a() that comes after a closing parenthesis
                            const chainFunctionMatch = lookbackNoWS.match(/(\.(?:n|a))$/);

                            let isChainItem = false;

                            if (modifierMatch) {
                                // This is definitely a modifier - any modifier inside sequence block is a chain item
                                isChainItem = true;
                            } else if (chainFunctionMatch) {
                                // This might be a chained .n() or .a()
                                // Check if it comes after a closing parenthesis (meaning it's chained)
                                // Look backwards in the original text (with whitespace) to find the previous )
                                let searchPos = charIndex - 1;
                                let parenDepth = 0;
                                let foundClosingParen = false;

                                while (searchPos >= 0) {
                                    const charAtPos = fullText[searchPos];
                                    if (charAtPos === ')') {
                                        parenDepth++;
                                        foundClosingParen = true;
                                        break;
                                    } else if (charAtPos === '(') {
                                        if (parenDepth > 0) parenDepth--;
                                        else break; // Hit the opening of current function
                                    }
                                    searchPos--;
                                }

                                if (foundClosingParen) {
                                    // This .n() or .a() comes after a closing ), so it's chained
                                    isChainItem = true;
                                }
                            }

                            if (isChainItem) {
                                // All chained items inside sequence blocks share level 1
                                modifierParentLevel = 0;
                                isModifier = true;
                            }
                        }

                        let level;
                        // For [ brackets, ALWAYS sequence level 0
                        if (char === '[') {
                            level = 0;
                            insideSeqBlock = true;
                            seqLevel = 1;
                        } else if (isSeqBracket) {
                            if (isModifierAfterBracket) {
                                // Modifier right after ] - same level as brackets (level 0)
                                level = 0;
                                insideSeqBlock = true; // Treat as still part of sequence
                                seqLevel = 1;
                            } else if (isModifier && modifierParentLevel !== null) {
                                // Use level 1 for all chained items (modifiers and chained functions)
                                level = modifierParentLevel;
                                // Don't increment seqLevel - chained items share the same level
                            } else if (insideSeqBlock) {
                                // Check if this is the first n() or a() in the sequence block
                                const lookbackRaw = fullText.substring(0, charIndex);
                                const lookbackNoWS = lookbackRaw.replace(/\s+/g, '');

                                // Check if this is directly after [ (first function in sequence)
                                const firstFuncMatch = lookbackNoWS.match(/\[[^[]*(n|a)$/);

                                // OR check if this is n() or a() that comes after something ending with )
                                // (meaning it might be chained but not detected yet)
                                const afterClosingParenMatch = lookbackNoWS.match(/\)(n|a)$/);

                                if (firstFuncMatch || afterClosingParenMatch) {
                                    // First n() or a() in sequence block, or chained n()/a() gets level 1
                                    level = 1;
                                    seqLevel = 2; // Keep seqLevel at 2 for nested brackets
                                } else {
                                    // Other brackets inside sequence block (nested content)
                                    level = seqLevel;
                                    seqLevel++;
                                }
                            } else {
                                level = 2;
                                seqLevel = 0;
                                insideSeqBlock = false;
                            }
                        } else {
                            // Check if this is t() - always use level 0 (same color)
                            if (char === '(') {
                                const lookbackRaw = fullText.substring(0, charIndex);
                                // Remove whitespace for matching
                                const lookbackNoWS = lookbackRaw.replace(/\s+/g, '');

                                // Check if this is t( - must end with "t" (optionally with whitespace removed)
                                // This means the last non-whitespace character before this ( is "t"
                                const isTFunction = lookbackNoWS.match(/t$/) !== null;

                                if (isTFunction) {
                                    level = 0; // t() always uses level 0 (Red)
                                    // Reset trackLevel to 1 for the next track-level bracket
                                    // This ensures each t() chain starts fresh
                                    trackLevel = 1;
                                } else {
                                    level = trackLevel;
                                    trackLevel++;
                                }
                            } else {
                                level = trackLevel;
                                trackLevel++;
                            }

                            if (char === '(' && !isSeqBracket) {
                                insideSeqBlock = false;
                            }
                        }

                        brackets.push({
                            char,
                            index: charIndex,
                            isSeqBracket: isSeqBracket,
                            level: level,
                            modifierParentLevel: isModifier ? modifierParentLevel : undefined
                        });

                        const span = document.createElement('span');
                        span.className = isError ? 'bracket error' : 'bracket';

                        if (isError) {
                            span.style.color = '#ff6b6b';
                        } else if (isSeqBracket) {
                            span.className += ` bracket-seq-${level % 4}`;
                        } else {
                            span.className += ` bracket-track-${level % 4}`;
                        }

                        span.textContent = char;
                        result.appendChild(span);
                    }
                    // Check if it's a closing bracket
                    else if (closingBrackets[char]) {
                        let matched = false;
                        if (brackets.length > 0) {
                            const lastBracket = brackets[brackets.length - 1];
                            if (closingBrackets[char] === lastBracket.char) {
                                const wasSeqBracket = lastBracket.isSeqBracket;
                                const bracketLevel = lastBracket.level;
                                brackets.pop();

                                // Update levels
                                if (wasSeqBracket) {
                                    if (char === ']') {
                                        seqLevel = 0;
                                        insideSeqBlock = false; // Set to false, but modifiers after ] will be detected and handled
                                    } else {
                                        // Only decrement seqLevel if this wasn't a modifier
                                        // Modifiers don't increment seqLevel, so they shouldn't decrement it
                                        if (lastBracket.modifierParentLevel === undefined) {
                                            seqLevel = Math.max(0, seqLevel - 1);
                                        }
                                        // If it was a modifier, seqLevel stays the same
                                        // If modifierParentLevel is 0, it means it's a modifier after ] - keep insideSeqBlock true
                                        if (lastBracket.modifierParentLevel !== 0) {
                                            // Only set insideSeqBlock false if this wasn't a modifier after ]
                                            // (Other modifiers inside sequence block will be handled by other logic)
                                        }
                                    }
                                } else {
                                    // Check if this closing bracket is for t()
                                    // The opening bracket's level would be 0 if it was t()
                                    // We can check the lookback to confirm it's t()
                                    if (bracketLevel === 0 && !wasSeqBracket) {
                                        // Check if the opening bracket was actually t() by looking at stored info
                                        // Since t() always uses level 0, and we're closing a track bracket at level 0,
                                        // this is likely t(). Reset trackLevel for next t() chain
                                        const lookbackRaw = fullText.substring(0, lastBracket.index);
                                        const lookbackNoWS = lookbackRaw.replace(/\s+/g, '');
                                        if (lookbackNoWS.match(/t$/)) {
                                            // This is closing t() - reset trackLevel so next t() starts fresh
                                            trackLevel = 0;
                                        } else {
                                            // Not t(), just happens to be level 0 - normal decrement
                                            trackLevel = Math.max(0, trackLevel - 1);
                                        }
                                    } else {
                                        trackLevel = Math.max(0, trackLevel - 1);
                                    }
                                }

                                matched = true;
                                const span = document.createElement('span');
                                span.className = isError ? 'bracket error' : 'bracket';

                                if (isError) {
                                    span.style.color = '#ff6b6b';
                                } else if (wasSeqBracket) {
                                    span.className += ` bracket-seq-${bracketLevel % 4}`;
                                } else {
                                    span.className += ` bracket-track-${bracketLevel % 4}`;
                                }

                                span.textContent = char;
                                result.appendChild(span);
                            }
                        }
                        if (!matched) {
                            const span = document.createElement('span');
                            span.className = 'bracket error';
                            span.textContent = char;
                            result.appendChild(span);
                        }
                    }
                    // Regular character
                    else {
                        const span = document.createElement('span');
                        span.className = isError ? 'char error' : 'char';
                        span.textContent = char;
                        result.appendChild(span);
                    }

                    charIndex++;
                }

                // Add newline (except after last line)
                if (lineIndex < lines.length - 1) {
                    const newlineSpan = document.createElement('span');
                    newlineSpan.className = 'char';
                    newlineSpan.textContent = '\n';
                    result.appendChild(newlineSpan);
                    charIndex++;
                }
            }

            return result;
        }

        // Legacy function for backward compatibility - now calls the new function
        function highlightLine(line) {
            if (!line) {
                return document.createDocumentFragment();
            }

            const result = document.createDocumentFragment();
            const bracketChars = { '(': ')', '[': ']', '{': '}', '<': '>' };
            const closingBrackets = { ')': '(', ']': '[', '}': '{', '>': '<' };
            const trackColors = [
                '#ff6b6b', /* Red */
                '#4a9eff', /* Blue */
                '#ffd93d', /* Yellow */
                '#6bcf7f'  /* Green */
            ];

            const seqColors = [
                '#ff8c42', /* Orange */
                '#9b59b6', /* Purple */
                '#00d9ff', /* Cyan */
                '#ff44aa'  /* Pink */
            ];

            const stack = []; // Track bracket pairs: { char, index, level }
            const errors = new Set(); // Track error positions

            // First pass: validate brackets from front to back
            for (let i = 0; i < line.length; i++) {
                const char = line[i];
                const nextChar = i < line.length - 1 ? line[i + 1] : '';

                // Skip comments - no bracket validation inside comments
                if (char === '/' && nextChar === '/') {
                    break; // Rest of line is comment, stop validation
                }

                if (bracketChars[char]) {
                    // Opening bracket
                    stack.push({ char, index: i, level: stack.length });
                } else if (closingBrackets[char]) {
                    // Closing bracket
                    if (stack.length === 0 || closingBrackets[char] !== stack[stack.length - 1].char) {
                        // Mismatched or unmatched closing bracket
                        errors.add(i);
                    } else {
                        stack.pop();
                    }
                }
            }

            // Mark any unmatched opening brackets as errors
            stack.forEach(item => errors.add(item.index));

            // Second pass: build the HTML with spans for each character
            const brackets = []; // Track current bracket stack: { char, index, isSeqBracket, level }
            let trackLevel = 0; // Track level for track brackets (t(), .play(), etc.)
            let seqLevel = 0; // Sequence level for sequence brackets ([...], .c(), etc.)
            let insideSeqBlock = false; // Track if we're currently inside a [ ... ] block

            // Helper to determine if a bracket is sequence-level
            function determineBracketType(char, lookback) {
                // [ and ] are ALWAYS sequence level, regardless of context
                if (char === '[' || char === ']') {
                    return { isSeq: true, reason: 'sequence-block' };
                }

                if (char === '(' || char === ')') {
                    // Sequence modifiers - these are always sequence level
                    const seqModifiers = ['.c', '.co', '.nRange', '.vRange', '.dRange', '.nArp', '.vArp', '.dArp', '.pm', '.pr', '.v', '.d', '.p', '.n', '.a'];
                    // Track modifiers - these are always track level
                    const trackModifiers = ['.play', '.bpm', '.sn', '.sd', '.ds', '.stop'];

                    // Check what comes immediately before this bracket
                    const modifierMatch = lookback.match(/([a-zA-Z0-9_]+|\.\w+)\s*$/);
                    if (modifierMatch) {
                        const modifier = modifierMatch[1];

                        // Check for function calls like n(, a(
                        if (modifier.match(/^(n|a)$/)) {
                            // n( or a( - check if inside sequence block
                            // Look for previous [ or ]
                            let inSeq = false;
                            let depth = 0;
                            for (let k = lookback.length - 1; k >= 0; k--) {
                                if (lookback[k] === ']') depth++;
                                else if (lookback[k] === '[') {
                                    depth--;
                                    if (depth === 0) {
                                        inSeq = true;
                                        break;
                                    }
                                }
                            }
                            return { isSeq: inSeq, reason: inSeq ? 'sequence-function' : 'track-function' };
                        }

                        // Check for dot modifiers
                        if (modifier.startsWith('.')) {
                            if (seqModifiers.some(m => modifier === m)) {
                                return { isSeq: true, reason: 'sequence-modifier' };
                            } else if (trackModifiers.some(m => modifier === m)) {
                                return { isSeq: false, reason: 'track-modifier' };
                            }
                        }
                    }

                    // Check if we're inside a sequence block [ ... ]
                    let bracketDepth = 0;
                    let foundSeqBlock = false;
                    for (let k = lookback.length - 1; k >= 0; k--) {
                        if (lookback[k] === ']') bracketDepth++;
                        else if (lookback[k] === '[') {
                            bracketDepth--;
                            if (bracketDepth === 0) {
                                foundSeqBlock = true;
                                break;
                            }
                        }
                    }

                    // Check for track-level function calls first (before checking sequence block)
                    // Check if it's t(, .play(, .bpm(, .sn(, .sd(, .ds(, .stop(
                    if (lookback.trim().match(/(t|\.play|\.bpm|\.sn|\.sd|\.ds|\.stop)\s*\(\s*$/)) {
                        return { isSeq: false, reason: 'track-declaration-or-modifier' };
                    }

                    if (foundSeqBlock) {
                        return { isSeq: true, reason: 'inside-sequence-block' };
                    }

                    // Default to track level
                    return { isSeq: false, reason: 'default-track' };
                }

                return { isSeq: false, reason: 'unknown' };
            }

            for (let i = 0; i < line.length; i++) {
                const char = line[i];
                const nextChar = i < line.length - 1 ? line[i + 1] : '';

                // Check for comment start
                if (char === '/' && nextChar === '/') {
                    // Add rest of line character by character as normal text (comment)
                    for (let j = i; j < line.length; j++) {
                        const span = document.createElement('span');
                        span.className = 'char';
                        span.textContent = line[j];
                        result.appendChild(span);
                    }
                    break;
                }

                // Check if this character is an error
                const isError = errors.has(i);

                // Check if it's an opening bracket
                if (bracketChars[char]) {
                    const lookback = line.substring(0, i);
                    const bracketInfo = determineBracketType(char, lookback);
                    const isSeqBracket = bracketInfo.isSeq;

                    let level;
                    // For [ brackets, ALWAYS sequence level 0, regardless of any previous state
                    if (char === '[') {
                        level = 0; // Always start sequence blocks at level 0
                        insideSeqBlock = true;
                        seqLevel = 1; // Next bracket inside [ will be at seqLevel 1
                    } else if (isSeqBracket) {
                        if (insideSeqBlock) {
                            level = seqLevel;
                            seqLevel++;
                        } else {
                            // Sequence modifier after ] block - reset and start at 0
                            level = 0;
                            seqLevel = 1;
                            insideSeqBlock = false; // Modifiers after ] are not "inside" the block
                        }
                    } else {
                        level = trackLevel;
                        trackLevel++;
                        // Track brackets are not inside sequence blocks
                        if (char === '(' && !isSeqBracket) {
                            insideSeqBlock = false;
                        }
                    }

                    // Store bracket with its type and level
                    brackets.push({ char, index: i, isSeqBracket: isSeqBracket, level: level });

                    const span = document.createElement('span');
                    span.className = isError ? 'bracket error' : 'bracket';

                    if (isError) {
                        span.style.color = '#ff6b6b';
                    } else if (isSeqBracket) {
                        span.className += ` bracket-seq-${level % 4}`;
                    } else {
                        span.className += ` bracket-track-${level % 4}`;
                    }

                    span.textContent = char;
                    result.appendChild(span);
                }
                // Check if it's a closing bracket
                else if (closingBrackets[char]) {
                    let matched = false;
                    if (brackets.length > 0) {
                        const lastBracket = brackets[brackets.length - 1];
                        if (closingBrackets[char] === lastBracket.char) {
                            // Use the stored level from the opening bracket
                            const wasSeqBracket = lastBracket.isSeqBracket;
                            const bracketLevel = lastBracket.level; // Use stored level, not current
                            brackets.pop();

                            // Update levels AFTER using the stored level
                            if (wasSeqBracket) {
                                if (char === ']') {
                                    // Reset sequence level when closing a sequence block
                                    seqLevel = 0;
                                    insideSeqBlock = false;
                                } else {
                                    seqLevel = Math.max(0, seqLevel - 1);
                                }
                            } else {
                                trackLevel = Math.max(0, trackLevel - 1);
                            }

                            matched = true;
                            const span = document.createElement('span');
                            span.className = isError ? 'bracket error' : 'bracket';

                            if (isError) {
                                span.style.color = '#ff6b6b';
                            } else if (wasSeqBracket) {
                                span.className += ` bracket-seq-${bracketLevel % 4}`;
                            } else {
                                span.className += ` bracket-track-${bracketLevel % 4}`;
                            }

                            span.textContent = char;
                            result.appendChild(span);
                        }
                    }
                    if (!matched) {
                        // Unmatched closing bracket
                        const span = document.createElement('span');
                        span.className = 'bracket error';
                        span.textContent = char;
                        result.appendChild(span);
                    }
                }
                // Regular character - wrap each one in a span
                else {
                    const span = document.createElement('span');
                    span.className = isError ? 'char error' : 'char';
                    span.textContent = char;
                    result.appendChild(span);
                }
            }

            return result;
        }

        // Update highlighting on any text change
        commandArea.addEventListener('input', () => {
            if (highlightOverlay) {
                highlightBrackets();
            }
        });

        commandArea.addEventListener('keyup', () => {
            if (highlightOverlay) {
                highlightBrackets();
            }
        });

        commandArea.addEventListener('paste', () => {
            setTimeout(() => {
                if (highlightOverlay) {
                    highlightBrackets();
                }
            }, 0);
        });

        // Also update on change event
        commandArea.addEventListener('change', () => {
            if (highlightOverlay) {
                highlightBrackets();
            }
        });

        // Sync scroll between textarea and overlay
        commandArea.addEventListener('scroll', () => {
            if (highlightOverlay) {
                highlightOverlay.scrollTop = commandArea.scrollTop;
                highlightOverlay.scrollLeft = commandArea.scrollLeft;
            }
        });

        // Initialize highlighting when DOM is ready
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', () => {
                initHighlighting();
            });
        } else {
            initHighlighting();
        }

        // Focus textarea on load and ensure highlighting is active
        window.addEventListener('load', () => {
            if (!highlightOverlay) {
                initHighlighting();
            }
            commandArea.focus();
            highlightBrackets();
        });

        // Hint show/hide functionality
        const hint = document.getElementById('hint');
        const hintClose = document.getElementById('hintClose');
        const hintToggle = document.getElementById('hintToggle');

        function hideHint() {
            hint.classList.add('hidden');
            hintToggle.classList.remove('hidden');
            hintToggle.classList.add('flex');
        }

        function showHint() {
            hint.classList.remove('hidden');
            hintToggle.classList.add('hidden');
            hintToggle.classList.remove('flex');
        }

        if (hintClose) {
            hintClose.addEventListener('click', hideHint);
        }

        if (hintToggle) {
            hintToggle.addEventListener('click', showHint);
        }

        // Cleanup on page unload
        window.addEventListener('beforeunload', () => {
            if (reconnectTimeout) {
                clearTimeout(reconnectTimeout);
            }
            if (ws) {
                ws.onclose = null; // Prevent reconnect on manual close
                ws.close();
            }
        });
    </script>
</body>

</html>